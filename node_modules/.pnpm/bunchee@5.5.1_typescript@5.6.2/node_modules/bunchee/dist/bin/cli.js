#!/usr/bin/env node
var path = require('path');
var arg = require('arg');
var perf_hooks = require('perf_hooks');
var fs = require('fs');
var fsp = require('fs/promises');
var require$$0 = require('tty');
var index_js = require('../index.js');
require('module');
var prettyBytes = require('pretty-bytes');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var arg__default = /*#__PURE__*/_interopDefault(arg);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var fsp__default = /*#__PURE__*/_interopDefault(fsp);
var require$$0__default = /*#__PURE__*/_interopDefault(require$$0);
var prettyBytes__default = /*#__PURE__*/_interopDefault(prettyBytes);

const availableExtensions = new Set([
    'js',
    'cjs',
    'mjs',
    'jsx',
    'ts',
    'tsx',
    'cts',
    'mts'
]);
// You can find the list of runtime keys here:
// https://runtime-keys.proposal.wintercg.org/
const runtimeExportConventions = new Set([
    'electron',
    'react-server',
    'react-native',
    'edge-light',
    'node',
    'deno',
    'bun',
    'workerd',
    // Browser only
    'browser'
]);
const optimizeConventions = new Set([
    'development',
    'production'
]);
const specialExportConventions = new Set([
    ...runtimeExportConventions,
    ...optimizeConventions
]);
const SRC = 'src';
const DIST = 'dist';
const dtsExtensionsMap = {
    js: 'd.ts',
    cjs: 'd.cts',
    mjs: 'd.mts'
};
const tsExtensions = new Set([
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const DEFAULT_TS_CONFIG = {
    compilerOptions: {
        module: 'ESNext',
        moduleResolution: 'bundler'
    }
};
const BINARY_TAG = '$binary';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let tty = require$$0__default.default;
	let isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
	let formatter = (open, close, replace = open)=>(input)=>{
	        let string = "" + input;
	        let index = string.indexOf(close, open.length);
	        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	    };
	let replaceClose = (string, close, replace, index)=>{
	    let start = string.substring(0, index) + replace;
	    let end = string.substring(index + close.length);
	    let nextIndex = end.indexOf(close);
	    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
	};
	let createColors = (enabled = isColorSupported)=>({
	        isColorSupported: enabled,
	        reset: enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String,
	        bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	        dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	        italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
	        underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
	        inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
	        hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
	        strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
	        black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
	        red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
	        green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
	        yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
	        blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
	        magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
	        cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
	        white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
	        gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
	        bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
	        bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
	        bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
	        bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
	        bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
	        bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
	        bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
	        bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String
	    });
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
var pc = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const defaultColorFn = (text)=>text;
function color(prefixColor) {
    return pc.isColorSupported ? pc[prefixColor] : defaultColorFn;
}
const logger = {
    log (...arg) {
        console.log(...arg);
    },
    warn (...arg) {
        console.warn(color('yellow')('⚠️'), ...arg);
    },
    error (...arg) {
        console.error(color('red')('⨯'), ...arg);
    },
    info (...arg) {
        console.log(color('green')('✓'), ...arg);
    }
};

function exit(err) {
    logger.error(err);
    process.exit(1);
}
function hasPackageJson(cwd) {
    return fileExists(path__default.default.resolve(cwd, 'package.json'));
}
async function getPackageMeta(cwd) {
    const pkgFilePath = path__default.default.resolve(cwd, 'package.json');
    let targetPackageJson = {};
    try {
        targetPackageJson = JSON.parse(await fsp__default.default.readFile(pkgFilePath, {
            encoding: 'utf-8'
        }));
    } catch (_) {}
    return targetPackageJson;
}
function isTypescriptFile(filename) {
    const ext = path__default.default.extname(filename).slice(1);
    return tsExtensions.has(ext);
}
function fileExists(filePath) {
    return fs__default.default.existsSync(filePath);
}
// 'index.server.js' -> 'index'
const getFileBasename = (str)=>str.split('.')[0];
const hasCjsExtension = (filename)=>path__default.default.extname(filename) === '.cjs';
const getMainFieldExportType = (pkg)=>{
    const isEsmPkg = isESModulePackage(pkg.type);
    const mainExportType = isEsmPkg && pkg.main ? hasCjsExtension(pkg.main) ? 'require' : 'import' : 'require';
    return mainExportType;
};
// TODO: add unit test
const baseNameWithoutExtension = (filename)=>path__default.default.basename(filename, path__default.default.extname(filename));
const isTestFile = (filename)=>/\.(test|spec)$/.test(baseNameWithoutExtension(filename));
function joinRelativePath(...segments) {
    let result = path__default.default.join(...segments);
    // If the first segment starts with '.', ensure the result does too.
    if (segments[0] === '.' && !result.startsWith('.')) {
        result = './' + result;
    }
    return result;
}
function isESModulePackage(packageType) {
    return packageType === 'module';
}
function isBinExportPath(exportPath) {
    return exportPath === BINARY_TAG || exportPath.startsWith(BINARY_TAG + '/');
}
function isTypeFile(filename) {
    return filename.endsWith('.d.ts') || filename.endsWith('.d.mts') || filename.endsWith('.d.cts');
}

function collectExportPath(exportValue, exportKey, currentPath, exportTypes, exportToDist) {
    // End of searching, export value is file path.
    // <export key>: <export value> (string)
    if (typeof exportValue === 'string') {
        const composedTypes = new Set(exportTypes);
        const exportType = exportKey.startsWith('.') ? 'default' : exportKey;
        composedTypes.add(exportType);
        const exportInfo = exportToDist.get(mapExportFullPath(currentPath));
        const exportCondition = Array.from(composedTypes).join('.');
        if (!exportInfo) {
            const outputConditionPair = [
                exportValue,
                exportCondition
            ];
            addToExportDistMap(exportToDist, currentPath, [
                outputConditionPair
            ], runtimeExportConventions.has(exportType) ? exportType : undefined);
        } else {
            exportInfo.push([
                exportValue,
                exportCondition
            ]);
        }
        return;
    }
    const exportKeys = Object.keys(exportValue);
    for (const exportKey of exportKeys){
        // Clone the set to avoid modifying the parent set
        const childExports = new Set(exportTypes);
        // Normalize child export value to a map
        const childExportValue = exportValue[exportKey];
        // Visit export path: ./subpath, ./subpath2, ...
        if (exportKey.startsWith('.')) {
            const childPath = joinRelativePath(currentPath, exportKey);
            collectExportPath(childExportValue, exportKey, childPath, childExports, exportToDist);
        } else {
            // Visit export type: import, require, ...
            childExports.add(exportKey);
            collectExportPath(childExportValue, exportKey, currentPath, childExports, exportToDist);
        }
    }
}
const mapExportFullPath = (exportPath)=>exportPath === '.' ? './index' : exportPath;
function addToExportDistMap(exportToDist, exportPath, outputConditionPairs, specialExportType) {
    const fullPath = mapExportFullPath(exportPath);
    // + (specialExportType ? '.' + specialExportType : '')
    const existingExportInfo = exportToDist.get(fullPath);
    if (!existingExportInfo) {
        exportToDist.set(fullPath, outputConditionPairs);
    } else {
        existingExportInfo.push(...outputConditionPairs);
    }
}
/**
 * parseExports - parse package.exports field and other fields like main,module to a map
 *
 * map from export path to output path and export conditions
 *
 * exportToDist: {
 *  './index': { development: ..., default: ... }
 *  './index.react-server': { development: ..., default: ... }
 * }
 */ function parseExports(pkg) {
    var _pkg_exports;
    const exportsField = (_pkg_exports = pkg.exports) != null ? _pkg_exports : {};
    var _pkg_bin;
    const bins = (_pkg_bin = pkg.bin) != null ? _pkg_bin : {};
    const exportToDist = new Map();
    const isEsmPkg = isESModulePackage(pkg.type);
    const defaultCondition = isEsmPkg ? 'import' : 'require';
    let currentPath = '.';
    if (typeof exportsField === 'string') {
        const outputConditionPair = [
            exportsField,
            defaultCondition
        ];
        addToExportDistMap(exportToDist, currentPath, [
            outputConditionPair
        ]);
    } else {
        // keys means unknown if they're relative path or export type
        const exportConditionKeys = Object.keys(exportsField);
        for (const exportKey of exportConditionKeys){
            const exportValue = exportsField[exportKey];
            const exportTypes = new Set();
            const isExportPath = exportKey.startsWith('.');
            const childPath = isExportPath ? joinRelativePath(currentPath, exportKey) : currentPath;
            if (!isExportPath) {
                exportTypes.add(exportKey);
            }
            collectExportPath(exportValue, exportKey, childPath, exportTypes, exportToDist);
        }
    }
    if (typeof bins === 'string') {
        const outputConditionPair = [
            bins,
            defaultCondition
        ];
        addToExportDistMap(exportToDist, BINARY_TAG, [
            outputConditionPair
        ]);
    } else {
        for (const binName of Object.keys(bins)){
            const binDistPath = bins[binName];
            const exportType = getExportTypeFromFile(binDistPath, pkg.type);
            const exportPath = path.posix.join(BINARY_TAG, binName);
            const outputConditionPair = [
                binDistPath,
                exportType
            ];
            addToExportDistMap(exportToDist, exportPath, [
                outputConditionPair
            ]);
        }
    }
    // Handle package.json global exports fields
    if (pkg.main || pkg.module || pkg.types) {
        const mainExportPath = pkg.main;
        const moduleExportPath = pkg.module;
        const typesEntryPath = pkg.types;
        addToExportDistMap(exportToDist, './index', [
            Boolean(mainExportPath) && [
                mainExportPath,
                getMainFieldExportType(pkg)
            ],
            Boolean(moduleExportPath) && [
                moduleExportPath,
                'module'
            ],
            Boolean(typesEntryPath) && [
                typesEntryPath,
                'types'
            ]
        ].filter(Boolean));
    }
    return exportToDist;
}
function getExportTypeFromFile(filename, pkgType) {
    const isESModule = isESModulePackage(pkgType);
    const isCjsExt = filename.endsWith('.cjs');
    const isEsmExt = filename.endsWith('.mjs');
    const exportType = isEsmExt ? 'import' : isCjsExt ? 'require' : isESModule ? 'import' : 'require';
    return exportType;
}

function validateTypesFieldCondition(pair) {
    const [outputPath, composedExportType] = pair;
    const exportTypes = new Set(composedExportType.split('.'));
    if (!exportTypes.has('types') && isTypeFile(outputPath)) {
        return true;
    }
    return false;
}
function lint$1(pkg) {
    const { name, main, exports } = pkg;
    const isESM = isESModulePackage(pkg.type);
    const parsedExports = parseExports(pkg);
    if (!name) {
        logger.warn('Missing package name');
    }
    const state = {
        badMainExtension: false,
        badMainExport: false,
        invalidExportsFieldType: false,
        badCjsRequireExport: {
            value: false,
            paths: []
        },
        badCjsImportExport: {
            value: false,
            paths: []
        },
        badEsmRequireExport: {
            value: false,
            paths: []
        },
        badEsmImportExport: {
            value: false,
            paths: []
        },
        badTypesExport: []
    };
    // Validate ESM package
    if (isESM) {
        if (exports) {
            if (typeof exports === 'string') {
                if (hasCjsExtension(exports)) {
                    state.badMainExport = true;
                }
            } else if (typeof exports !== 'object') {
                state.invalidExportsFieldType = true;
            } else {
                parsedExports.forEach((outputPairs)=>{
                    for (const outputPair of outputPairs){
                        const [outputPath, composedExportType] = outputPair;
                        if (validateTypesFieldCondition([
                            outputPath,
                            composedExportType
                        ])) {
                            state.badTypesExport.push([
                                outputPath,
                                composedExportType
                            ]);
                        }
                        const exportTypes = new Set(composedExportType.split('.'));
                        let requirePath = '';
                        let importPath = '';
                        if (exportTypes.has('require')) {
                            requirePath = outputPath;
                        }
                        if (exportTypes.has('import')) {
                            importPath = outputPath;
                        }
                        const requireExt = requirePath && path__default.default.extname(requirePath);
                        const importExt = importPath && path__default.default.extname(importPath);
                        if (requireExt === '.mjs' || requireExt === '.js') {
                            state.badEsmRequireExport.value = true;
                            state.badEsmRequireExport.paths.push(requirePath);
                        }
                        if (importExt === '.cjs') {
                            state.badEsmImportExport.value = true;
                            state.badEsmImportExport.paths.push(importPath);
                        }
                    }
                });
            }
        }
    } else {
        // Validate CJS package
        if (main && path__default.default.extname(main) === '.mjs') {
            state.badMainExtension = true;
        }
        if (exports) {
            if (typeof exports === 'string') {
                if (path__default.default.extname(exports) === '.mjs') {
                    state.badMainExport = true;
                }
            } else if (typeof exports !== 'object') {
                state.invalidExportsFieldType = true;
            } else {
                parsedExports.forEach((outputPairs)=>{
                    for (const outputPair of outputPairs){
                        const [outputPath, composedExportType] = outputPair;
                        if (validateTypesFieldCondition([
                            outputPath,
                            composedExportType
                        ])) {
                            state.badTypesExport.push([
                                outputPath,
                                composedExportType
                            ]);
                        }
                        const exportTypes = new Set(composedExportType.split('.'));
                        let requirePath = '';
                        let importPath = '';
                        if (exportTypes.has('require')) {
                            requirePath = outputPath;
                        }
                        if (exportTypes.has('import')) {
                            importPath = outputPath;
                        }
                        const requireExt = requirePath && path__default.default.extname(requirePath);
                        const importExt = importPath && path__default.default.extname(importPath);
                        if (requireExt === '.mjs') {
                            state.badCjsRequireExport.value = true;
                            state.badCjsRequireExport.paths.push(requirePath);
                        }
                        if (importExt === '.js' || importExt === '.cjs') {
                            state.badCjsImportExport.value = true;
                            state.badCjsImportExport.paths.push(importPath);
                        }
                    }
                });
            }
        }
    }
    if (state.badMainExtension) {
        logger.warn('Cannot export `main` field with .mjs extension in CJS package, only .js extension is allowed');
    }
    if (state.badMainExport) {
        if (isESM) {
            logger.warn('Cannot export `exports` field with .cjs extension in ESM package, only .mjs and .js extensions are allowed');
        } else {
            logger.warn('Cannot export `exports` field with .mjs extension in CJS package, only .js and .cjs extensions are allowed');
        }
    }
    if (state.invalidExportsFieldType) {
        logger.warn('Invalid exports field type, only object or string is allowed');
    }
    if (state.badCjsRequireExport.value) {
        logger.warn('Cannot export `require` field with .mjs extension in CJS package, only .cjs and .js extensions are allowed');
        state.badCjsRequireExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badCjsImportExport.value) {
        logger.warn('Cannot export `import` field with .js or .cjs extension in CJS package, only .mjs extensions are allowed');
        state.badCjsImportExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badEsmRequireExport.value) {
        logger.warn('Cannot export `require` field with .js or .mjs extension in ESM package, only .cjs extensions are allowed');
        state.badEsmRequireExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badEsmImportExport.value) {
        logger.warn('Cannot export `import` field with .cjs extension in ESM package, only .js and .mjs extensions are allowed');
        state.badEsmImportExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badTypesExport.length) {
        state.badTypesExport.forEach(([outputPath, composedExportType])=>{
            logger.error(`Bad export types field with ${composedExportType} in ${outputPath}, use "types" export condition for it`);
        });
        process.exit(1);
    }
}

var version = "5.5.1";

function relativify(path) {
    return path.startsWith('.') ? path : `./${path}`;
}

async function writeDefaultTsconfig(tsConfigPath) {
    await fs.promises.writeFile(tsConfigPath, JSON.stringify(DEFAULT_TS_CONFIG, null, 2), 'utf-8');
    logger.log(`Detected using TypeScript but tsconfig.json is missing, created a ${pc.blue('tsconfig.json')} for you.`);
}

// shared.ts -> ./shared
// shared.<export condition>.ts -> ./shared
// index.ts -> ./index
// index.development.ts -> ./index.development
function sourceFilenameToExportFullPath(filename) {
    const baseName = baseNameWithoutExtension(filename);
    let exportPath = baseName;
    return relativify(exportPath);
}
// ./index -> default
// ./index.development -> development
// ./index.react-server -> react-server
function getExportTypeFromExportPath(exportPath) {
    // Skip the first two segments: `.` and `index`
    const exportTypes = exportPath.split('.').slice(2);
    return getExportTypeFromExportTypesArray(exportTypes);
}
function getSpecialExportTypeFromComposedExportPath(composedExportType) {
    const exportTypes = composedExportType.split('.');
    for (const exportType of exportTypes){
        if (specialExportConventions.has(exportType)) {
            return exportType;
        }
    }
    return 'default';
}
function getExportTypeFromExportTypesArray(types) {
    let exportType = 'default';
    new Set(types).forEach((value)=>{
        if (specialExportConventions.has(value)) {
            exportType = value;
        } else if (value === 'import' || value === 'require' || value === 'types') {
            exportType = value;
        }
    });
    return exportType;
}
// ./index -> .
// ./index.development -> .
// ./index.react-server -> .
// ./shared -> ./shared
// ./shared.development -> ./shared
// $binary -> $binary
// $binary/index -> $binary
// $binary/foo -> $binary/foo
function normalizeExportPath(exportPath) {
    if (exportPath.startsWith(BINARY_TAG)) {
        if (exportPath === `${BINARY_TAG}/index`) {
            exportPath = BINARY_TAG;
        }
        return exportPath;
    }
    const baseName = exportPath.split('.').slice(0, 2).join('.');
    if (baseName === './index') {
        return '.';
    }
    return baseName;
}
async function collectSourceEntriesByExportPath(sourceFolderPath, originalSubpath, bins, exportsEntries) {
    const isBinaryPath = isBinExportPath(originalSubpath);
    const subpath = originalSubpath.replace(BINARY_TAG, 'bin');
    const absoluteDirPath = path__default.default.join(sourceFolderPath, subpath);
    const isDirectory = fs__default.default.existsSync(absoluteDirPath) ? (await fsp__default.default.stat(absoluteDirPath)).isDirectory() : false;
    if (isDirectory) {
        if (isBinaryPath) {
            const binDirentList = await fsp__default.default.readdir(absoluteDirPath, {
                withFileTypes: true
            });
            for (const binDirent of binDirentList){
                if (binDirent.isFile()) {
                    const binFileAbsolutePath = path__default.default.join(absoluteDirPath, binDirent.name);
                    if (fs__default.default.existsSync(binFileAbsolutePath)) {
                        bins.set(normalizeExportPath(originalSubpath), binFileAbsolutePath);
                    }
                }
            }
        } else {
            // Search folder/index.<ext> convention entries
            for (const extension of availableExtensions){
                const indexAbsoluteFile = path__default.default.join(absoluteDirPath, `index.${extension}`);
                // Search folder/index.<special type>.<ext> convention entries
                for (const specialExportType of runtimeExportConventions){
                    const indexSpecialAbsoluteFile = path__default.default.join(absoluteDirPath, `index.${specialExportType}.${extension}`);
                    if (fs__default.default.existsSync(indexSpecialAbsoluteFile)) {
                        // Add special export path
                        // { ./<export path>.<special cond>: { <special cond>: 'index.<special cond>.<ext>' } }
                        const exportPath = relativify(subpath);
                        const specialExportPath = exportPath + '.' + specialExportType;
                        const sourceFilesMap = exportsEntries.get(specialExportPath) || {};
                        sourceFilesMap[specialExportType] = indexSpecialAbsoluteFile;
                        exportsEntries.set(specialExportPath, sourceFilesMap);
                    }
                }
                if (fs__default.default.existsSync(indexAbsoluteFile) && !isTestFile(indexAbsoluteFile)) {
                    const exportPath = relativify(subpath);
                    const sourceFilesMap = exportsEntries.get(exportPath) || {};
                    const exportType = getExportTypeFromExportPath(exportPath);
                    sourceFilesMap[exportType] = indexAbsoluteFile;
                    exportsEntries.set(exportPath, sourceFilesMap);
                }
            }
        }
    } else {
        // subpath could be a file
        const dirName = path.dirname(subpath);
        const baseName = path.basename(subpath);
        // Read current file's directory
        const dirPath = path__default.default.join(sourceFolderPath, dirName);
        if (!fs__default.default.existsSync(dirPath)) {
            return;
        }
        const dirents = await fsp__default.default.readdir(dirPath, {
            withFileTypes: true
        });
        for (const dirent of dirents){
            // index.development.js -> index.development
            const direntBaseName = baseNameWithoutExtension(dirent.name);
            const ext = path.extname(dirent.name).slice(1);
            if (!dirent.isFile() || direntBaseName !== baseName || !availableExtensions.has(ext)) {
                continue;
            }
            if (isTestFile(dirent.name)) {
                continue;
            }
            const sourceFileAbsolutePath = path__default.default.join(dirPath, dirent.name);
            if (isBinaryPath) {
                bins.set(originalSubpath, sourceFileAbsolutePath);
            } else {
                let sourceFilesMap = exportsEntries.get(originalSubpath) || {};
                const exportType = getExportTypeFromExportPath(originalSubpath);
                sourceFilesMap[exportType] = sourceFileAbsolutePath;
                if (specialExportConventions.has(exportType)) {
                    // e.g. ./foo/index.react-server -> ./foo/index
                    const fallbackExportPath = sourceFilenameToExportFullPath(originalSubpath);
                    const fallbackSourceFilesMap = exportsEntries.get(fallbackExportPath) || {};
                    sourceFilesMap = {
                        ...fallbackSourceFilesMap,
                        ...sourceFilesMap
                    };
                }
                exportsEntries.set(originalSubpath, sourceFilesMap);
            }
        }
    }
}
// For `prepare`
async function collectSourceEntries(sourceFolderPath) {
    const bins = new Map();
    const exportsEntries = new Map();
    if (!fs__default.default.existsSync(sourceFolderPath)) {
        return {
            bins,
            exportsEntries
        };
    }
    const entryFileDirentList = await fsp__default.default.readdir(sourceFolderPath, {
        withFileTypes: true
    });
    // Collect source files for `exports` field
    for (const dirent of entryFileDirentList){
        if (getFileBasename(dirent.name) === 'bin') {
            continue;
        }
        const exportPath = sourceFilenameToExportFullPath(dirent.name);
        await collectSourceEntriesByExportPath(sourceFolderPath, exportPath, bins, exportsEntries);
    }
    // Collect source files for `bin` field
    const binDirent = entryFileDirentList.find((dirent)=>getFileBasename(dirent.name) === 'bin');
    if (binDirent) {
        if (binDirent.isDirectory()) {
            const binDirentList = await fsp__default.default.readdir(path__default.default.join(sourceFolderPath, binDirent.name), {
                withFileTypes: true
            });
            for (const binDirent of binDirentList){
                const binExportPath = path.posix.join(BINARY_TAG, getFileBasename(binDirent.name));
                await collectSourceEntriesByExportPath(sourceFolderPath, binExportPath, bins, exportsEntries);
            }
        } else {
            await collectSourceEntriesByExportPath(sourceFolderPath, BINARY_TAG, bins, exportsEntries);
        }
    }
    return {
        bins,
        exportsEntries
    };
}

// Output with posix style in package.json
function getDistPath(...subPaths) {
    return relativify(path.posix.join(DIST, ...subPaths));
}
function stripeBinaryTag(exportName) {
    // Add \ to decode leading $
    return exportName.replace(/\$binary\//, '');
}
const normalizeBaseNameToExportName = (name)=>{
    const baseName = stripeBinaryTag(name);
    return /^\.\/index(\.|$)/.test(baseName) ? '.' : relativify(baseName);
};
function createExportCondition(exportName, sourceFile, moduleType) {
    const isTsSourceFile = isTypescriptFile(sourceFile);
    let cjsExtension = 'js';
    let esmExtension = 'mjs';
    if (moduleType === 'module') {
        cjsExtension = 'cjs';
        esmExtension = 'js';
    }
    if (exportName === '.') {
        exportName = 'index';
    }
    if (isTsSourceFile) {
        return {
            import: {
                types: getDistPath('es', `${exportName}.${dtsExtensionsMap[esmExtension]}`),
                default: getDistPath('es', `${exportName}.${esmExtension}`)
            },
            require: {
                types: getDistPath('cjs', `${exportName}.${dtsExtensionsMap[cjsExtension]}`),
                default: getDistPath('cjs', `${exportName}.${cjsExtension}`)
            }
        };
    }
    return {
        import: getDistPath(`${exportName}.mjs`),
        require: getDistPath(`${exportName}.${cjsExtension}`)
    };
}
function createExportConditionPair(exportName, sourceFile, moduleType) {
    // <exportName>.<specialCondition>
    let specialCondition;
    const specialConditionName = getSpecialExportTypeFromComposedExportPath(exportName);
    const normalizedExportPath = normalizeExportPath(exportName);
    if (specialConditionName !== 'default') {
        // e.g.
        // ./index.develop -> index
        // ./foo.react-server -> foo
        const fileBaseName = exportName.split('.').slice(0, 2).join('.').replace('./', '');
        specialCondition = {
            [specialConditionName]: getDistPath('es', `${fileBaseName}-${specialConditionName}.mjs`)
        };
        return [
            normalizedExportPath,
            specialCondition
        ];
    }
    const exportCond = createExportCondition(exportName, sourceFile, moduleType);
    return [
        normalizedExportPath,
        exportCond
    ];
}
async function prepare(cwd) {
    const sourceFolder = path__default.default.resolve(cwd, SRC);
    if (!fs__default.default.existsSync(sourceFolder)) {
        logger.error(`Source folder ${sourceFolder} does not exist. Cannot proceed to configure \`exports\` field.`);
        process.exit(1);
    }
    let hasPackageJson = false;
    const pkgJsonPath = path__default.default.join(cwd, 'package.json');
    let pkgJson = {};
    if (fs__default.default.existsSync(pkgJsonPath)) {
        hasPackageJson = true;
        const pkgJsonString = await fsp__default.default.readFile(pkgJsonPath, 'utf-8');
        pkgJson = JSON.parse(pkgJsonString);
    }
    // configure `files` field with `dist`
    const files = pkgJson.files || [];
    if (!files.includes(DIST)) {
        files.push(DIST);
    }
    pkgJson.files = files;
    let isUsingTs = false;
    // Collect bins and exports entries
    const { bins, exportsEntries } = await collectSourceEntries(sourceFolder);
    const tsConfigPath = path__default.default.join(cwd, 'tsconfig.json');
    const exportsSourceFiles = [
        ...exportsEntries.values()
    ].reduce((acc, sourceFiles)=>{
        Object.values(sourceFiles).forEach((sourceFile)=>acc.add(sourceFile));
        return acc;
    }, new Set());
    const allSourceFiles = [
        ...exportsSourceFiles,
        ...bins.values()
    ].map((absoluteFilePath)=>absoluteFilePath);
    const hasTypeScriptFiles = allSourceFiles.some((filename)=>isTypescriptFile(filename));
    if (hasTypeScriptFiles) {
        isUsingTs = true;
        if (!fs__default.default.existsSync(tsConfigPath)) {
            await writeDefaultTsconfig(tsConfigPath);
        }
    }
    // Configure as ESM package by default if there's no package.json
    if (!hasPackageJson) {
        pkgJson.type = 'module';
    }
    if (bins.size > 0) {
        logger.log('Discovered binaries entries:');
        const maxLengthOfBinName = Math.max(...Array.from(bins.keys()).map((binName)=>normalizeBaseNameToExportName(binName).length));
        for (const [binName, binFile] of bins.entries()){
            const spaces = ' '.repeat(Math.max(maxLengthOfBinName - normalizeBaseNameToExportName(binName).length, 0));
            logger.log(`  ${normalizeBaseNameToExportName(binName)}${spaces}: ${path__default.default.basename(binFile)}`);
        }
        if (bins.size === 1 && bins.has(BINARY_TAG)) {
            pkgJson.bin = getDistPath('bin', 'index.js');
        } else {
            pkgJson.bin = {};
            for (const [binOriginName] of bins.entries()){
                const binName = stripeBinaryTag(binOriginName);
                pkgJson.bin[binName === '.' ? pkgJson.name : binName] = getDistPath('bin', binName + '.js');
            }
        }
    }
    if (exportsEntries.size > 0) {
        logger.log('Discovered exports entries:');
        const maxLengthOfExportName = Math.max(...Array.from(exportsEntries.keys()).map((exportName)=>normalizeBaseNameToExportName(exportName).length));
        for (const [exportName, sourceFilesMap] of exportsEntries.entries()){
            const spaces = ' '.repeat(Math.max(maxLengthOfExportName - normalizeBaseNameToExportName(exportName).length, 0));
            for (const exportFile of Object.values(sourceFilesMap)){
                logger.log(`  ${normalizeBaseNameToExportName(exportName)}${spaces}: ${path__default.default.basename(exportFile)}`);
            }
        }
        const pkgExports = {};
        for (const [exportName, sourceFilesMap] of exportsEntries.entries()){
            for (const sourceFile of Object.values(sourceFilesMap)){
                const [normalizedExportPath, conditions] = createExportConditionPair(exportName, sourceFile, pkgJson.type);
                pkgExports[normalizedExportPath] = {
                    ...conditions,
                    ...pkgExports[normalizedExportPath]
                };
            }
        }
        // Configure node10 module resolution
        if (exportsEntries.has('./index')) {
            const isESM = pkgJson.type === 'module';
            const mainExport = pkgExports['.'];
            const mainCondition = isESM ? 'import' : 'require';
            pkgJson.main = isUsingTs ? mainExport[mainCondition].default : mainExport[mainCondition];
            pkgJson.module = isUsingTs ? mainExport.import.default : mainExport.import;
            if (isUsingTs) {
                pkgJson.types = mainExport[mainCondition].types;
            }
        }
        // Assign the properties by order: files, main, module, types, exports
        if (Object.keys(pkgExports).length > 0) {
            if (!pkgJson.exports) {
                pkgJson.exports = pkgExports;
            } else {
                // Update existing exports
                Object.keys(pkgExports).forEach((exportName)=>{
                    if (pkgJson.exports[exportName]) {
                        pkgJson.exports[exportName] = pkgExports[exportName];
                    }
                });
            }
        }
    }
    await fsp__default.default.writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
    logger.info('Configured `exports` in package.json');
}

function normalizeExportName(exportName) {
    const isBinary = isBinExportPath(exportName);
    let result = exportName;
    if (isBinary) {
        result = (exportName.replace(new RegExp(`^\\${BINARY_TAG}\\/?`), '') || '.') + ' (bin)';
    } else {
        const normalizedExportPath = normalizeExportPath(exportName);
        const specialConditionName = getSpecialExportTypeFromComposedExportPath(exportName);
        result = normalizedExportPath + (specialConditionName !== 'default' ? ` (${specialConditionName})` : '');
    }
    return result;
}
function logOutputState(stats) {
    if (stats.size === 0) {
        logger.warn('No build info can be logged');
        return;
    }
    const allFileNameLengths = Array.from(stats.values()).flat(1).map(([filename])=>filename.length);
    const maxFilenameLength = Math.max(...allFileNameLengths);
    const statsArray = [
        ...stats.entries()
    ].sort(([a], [b])=>{
        const comp = normalizeExportPath(a).length - normalizeExportPath(b).length;
        return comp === 0 ? a.localeCompare(b) : comp;
    });
    const maxLengthOfExportName = Math.max(...statsArray.map(([exportName])=>normalizeExportName(exportName).length));
    console.log(pc.underline('Exports'), ' '.repeat(Math.max(maxLengthOfExportName - 'Exports'.length, 0)), pc.underline('File'), ' '.repeat(Math.max(maxFilenameLength - 'File'.length, 0)), pc.underline('Size'));
    statsArray.forEach(([exportName, filesList])=>{
        // sort by file type, first js files then types, js/mjs/cjs are prioritized than .d.ts/.d.mts/.d.cts
        filesList.sort(([a], [b])=>{
            const aIsType = isTypeFile(a);
            const bIsType = isTypeFile(b);
            if (aIsType && bIsType) {
                return 0;
            }
            if (aIsType) {
                return 1;
            }
            if (bIsType) {
                return -1;
            }
            return 0;
        }).forEach((item, index)=>{
            const [filename, , size] = item;
            const normalizedExportName = normalizeExportName(exportName);
            const prefix = index === 0 ? normalizedExportName : ' '.repeat(normalizedExportName.length);
            const filenamePadding = ' '.repeat(Math.max(maxLengthOfExportName, 'Exports'.length) - normalizedExportName.length);
            const isType = isTypeFile(filename);
            const sizePadding = ' '.repeat(Math.max(maxFilenameLength, 'File'.length) - filename.length);
            const prettiedSize = prettyBytes__default.default(size);
            console.log(prefix, filenamePadding, `${pc[isType ? 'dim' : 'bold'](filename)}`, sizePadding, prettiedSize);
        });
    });
}

const helpMessage = `
Usage: bunchee [options]

Options:
  -v, --version          output the version number
  -w, --watch            watch src files changes
  -m, --minify           compress output. default: false
  -o, --output <file>    specify output filename
  -f, --format <format>  type of output (esm, amd, cjs, iife, umd, system), default: esm
  -h, --help             output usage information
  --prepare              auto configure package.json exports for building
  --external <mod>       specify an external dependency, separate by comma
  --no-external          do not bundle external dependencies
  --no-clean             do not clean dist folder before building, default: false
  --target <target>      js features target: swc target es versions. default: es2015
  --runtime <runtime>    build runtime (nodejs, browser). default: browser
  --env <env>            inlined process env variables, separate by comma. default: NODE_ENV
  --cwd <cwd>            specify current working directory
  --sourcemap            enable sourcemap generation, default: false
  --no-dts               do not generate types, default: undefined
  --tsconfig             path to tsconfig file, default: tsconfig.json
  --dts-bundle           bundle type declaration files, default: false
`;
function help() {
    logger.log(helpMessage);
}
async function lint(cwd) {
    // Not package.json detected, skip package linting
    if (!await hasPackageJson(cwd)) {
        return;
    }
    await lint$1(await getPackageMeta(cwd));
}
function parseCliArgs(argv) {
    let args;
    args = arg__default.default({
        '--cwd': String,
        '--no-dts': Boolean,
        '--output': String,
        '--format': String,
        '--watch': Boolean,
        '--minify': Boolean,
        '--help': Boolean,
        '--version': Boolean,
        '--runtime': String,
        '--target': String,
        '--sourcemap': Boolean,
        '--env': String,
        '--external': String,
        '--no-external': Boolean,
        '--no-clean': Boolean,
        '--prepare': Boolean,
        '--tsconfig': String,
        '--dts-bundle': Boolean,
        '-h': '--help',
        '-v': '--version',
        '-w': '--watch',
        '-o': '--output',
        '-f': '--format',
        '-m': '--minify'
    }, {
        permissive: true,
        argv
    });
    const source = args._[0];
    const parsedArgs = {
        source,
        format: args['--format'],
        file: args['--output'],
        watch: args['--watch'],
        minify: args['--minify'],
        sourcemap: !!args['--sourcemap'],
        cwd: args['--cwd'],
        dts: args['--no-dts'] ? false : undefined,
        dtsBundle: args['--dts-bundle'],
        help: args['--help'],
        version: args['--version'],
        runtime: args['--runtime'],
        target: args['--target'],
        external: !!args['--no-external'] ? null : args['--external'],
        clean: !args['--no-clean'],
        env: args['--env'],
        prepare: !!args['--prepare'],
        tsconfig: args['--tsconfig']
    };
    return parsedArgs;
}
async function run(args) {
    var _args_external;
    const { source, format, watch, minify, sourcemap, target, runtime, dts, dtsBundle, env, clean, tsconfig } = args;
    const cwd = args.cwd || process.cwd();
    const file = args.file ? path__default.default.resolve(cwd, args.file) : undefined;
    const bundleConfig = {
        dts: dts !== false && {
            respectExternal: dtsBundle ? true : undefined
        },
        file,
        format,
        cwd,
        target,
        runtime,
        external: args.external === null ? null : ((_args_external = args.external) == null ? void 0 : _args_external.split(',')) || [],
        watch: !!watch,
        minify: !!minify,
        sourcemap: sourcemap === false ? false : true,
        env: (env == null ? void 0 : env.split(',')) || [],
        clean,
        tsconfig
    };
    if (args.version) {
        return logger.log(version);
    }
    if (args.help) {
        return help();
    }
    if (args.prepare) {
        return await prepare(cwd);
    }
    const cliEntry = source ? path__default.default.resolve(cwd, source) : '';
    // lint package
    await lint(cwd);
    const { default: ora } = await import('ora');
    const oraInstance = ora({
        text: 'Building...\n\n',
        color: 'green'
    });
    const spinner = {
        start: startSpinner,
        stop: stopSpinner
    };
    function startSpinner() {
        oraInstance.start();
    }
    function stopSpinner(text) {
        if (oraInstance.isSpinning) {
            oraInstance.clear();
            if (text) {
                oraInstance.stopAndPersist({
                    symbol: '✔',
                    text
                });
            } else {
                oraInstance.stop();
            }
        }
    }
    let initialBuildContext;
    function onBuildStart(buildContext) {
        initialBuildContext = buildContext;
        if (!watch) {
            spinner.start();
        }
    }
    function onBuildEnd(assetJobs) {
        // Stop spinner before logging output files and sizes on build end
        if (watch) {
            logWatcherBuildTime(assetJobs, spinner);
        } else {
            stopSpinner();
            if (assetJobs.length === 0) {
                logger.warn('The "src" directory does not contain any entry files. ' + 'For proper usage, please refer to the following link: ' + 'https://github.com/huozhi/bunchee#usage');
            }
            const outputState = initialBuildContext == null ? void 0 : initialBuildContext.pluginContext.outputState;
            if (outputState) {
                logOutputState(outputState.getSizeStats());
            }
        }
    }
    let buildError;
    bundleConfig._callbacks = {
        onBuildStart,
        onBuildEnd
    };
    if (watch) {
        logger.log(`Watching project ${cwd}...`);
    }
    try {
        await index_js.bundle(cliEntry, bundleConfig);
    } catch (err) {
        if (err.name === 'NOT_EXISTED') {
            buildError = {
                digest: 'bunchee:not-existed',
                error: err
            };
        }
        if ((buildError == null ? void 0 : buildError.digest) === 'bunchee:not-existed') {
            help();
        } else {
            if (watch) {
                logError(err);
            } else {
                throw err;
            }
        }
    }
    // watching mode
    if (watch) {
        spinner.stop();
    } else {
        spinner.stop(`bunchee ${version} build completed`);
    }
}
async function main() {
    let params, error;
    try {
        params = parseCliArgs(process.argv.slice(2));
    } catch (err) {
        error = err;
    }
    if (error || !params) {
        if (!error) help();
        return exit(error);
    }
    await run(params);
}
function logWatcherBuildTime(result, spinner) {
    let watcherCounter = 0;
    let startTime = 0;
    result.map((watcher)=>{
        function start() {
            if (watcherCounter === 0) {
                startTime = perf_hooks.performance.now();
                spinner.start();
            }
            watcherCounter++;
        }
        function end() {
            watcherCounter--;
            if (watcherCounter === 0) {
                spinner.stop(`Built in ${(perf_hooks.performance.now() - startTime).toFixed(2)}ms`);
            }
        }
        watcher.on('event', (event)=>{
            switch(event.code){
                case 'ERROR':
                    {
                        spinner.stop();
                        logError(event.error);
                        break;
                    }
                case 'START':
                    {
                        start();
                        break;
                    }
                case 'END':
                    {
                        end();
                        break;
                    }
            }
        });
    });
}
function logError(error) {
    if (!error) return;
    // logging source code in format
    if (error.frame) {
        process.stderr.write(error.frame + '\n');
    }
}
main().catch(exit);
