Object.defineProperty(exports, '__esModule', { value: true });

var fsp = require('fs/promises');
var fs = require('fs');
var path = require('path');
require('pretty-bytes');
var require$$0 = require('tty');
var module$1 = require('module');
var rollup = require('rollup');
var pluginWasm = require('@rollup/plugin-wasm');
var rollupPluginSwc3 = require('rollup-plugin-swc3');
var commonjs = require('@rollup/plugin-commonjs');
var json = require('@rollup/plugin-json');
var pluginNodeResolve = require('@rollup/plugin-node-resolve');
var replace = require('@rollup/plugin-replace');
var preserveDirectives = require('rollup-preserve-directives');
var MagicString = require('magic-string');
var CleanCSS = require('clean-css');
var pluginutils = require('@rollup/pluginutils');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fsp__default = /*#__PURE__*/_interopDefault(fsp);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var require$$0__default = /*#__PURE__*/_interopDefault(require$$0);
var commonjs__default = /*#__PURE__*/_interopDefault(commonjs);
var json__default = /*#__PURE__*/_interopDefault(json);
var replace__default = /*#__PURE__*/_interopDefault(replace);
var preserveDirectives__default = /*#__PURE__*/_interopDefault(preserveDirectives);
var MagicString__default = /*#__PURE__*/_interopDefault(MagicString);
var CleanCSS__default = /*#__PURE__*/_interopDefault(CleanCSS);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let tty = require$$0__default.default;
	let isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
	let formatter = (open, close, replace = open)=>(input)=>{
	        let string = "" + input;
	        let index = string.indexOf(close, open.length);
	        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	    };
	let replaceClose = (string, close, replace, index)=>{
	    let start = string.substring(0, index) + replace;
	    let end = string.substring(index + close.length);
	    let nextIndex = end.indexOf(close);
	    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
	};
	let createColors = (enabled = isColorSupported)=>({
	        isColorSupported: enabled,
	        reset: enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String,
	        bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	        dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	        italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
	        underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
	        inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
	        hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
	        strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
	        black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
	        red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
	        green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
	        yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
	        blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
	        magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
	        cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
	        white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
	        gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
	        bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
	        bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
	        bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
	        bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
	        bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
	        bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
	        bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
	        bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String
	    });
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
var pc = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const defaultColorFn = (text)=>text;
function color(prefixColor) {
    return pc.isColorSupported ? pc[prefixColor] : defaultColorFn;
}
const logger = {
    log (...arg) {
        console.log(...arg);
    },
    warn (...arg) {
        console.warn(color('yellow')('⚠️'), ...arg);
    },
    error (...arg) {
        console.error(color('red')('⨯'), ...arg);
    },
    info (...arg) {
        console.log(color('green')('✓'), ...arg);
    }
};

const availableExtensions = new Set([
    'js',
    'cjs',
    'mjs',
    'jsx',
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const nodeResolveExtensions = [
    '.mjs',
    '.cjs',
    '.js',
    '.json',
    '.node',
    '.jsx'
];
// You can find the list of runtime keys here:
// https://runtime-keys.proposal.wintercg.org/
const runtimeExportConventions = new Set([
    'electron',
    'react-server',
    'react-native',
    'edge-light',
    'node',
    'deno',
    'bun',
    'workerd',
    // Browser only
    'browser'
]);
const optimizeConventions = new Set([
    'development',
    'production'
]);
const specialExportConventions = new Set([
    ...runtimeExportConventions,
    ...optimizeConventions
]);
const availableESExtensionsRegex = /\.(m|c)?[jt]sx?$/;
const SRC = 'src';
const dtsExtensionsMap = {
    js: 'd.ts',
    cjs: 'd.cts',
    mjs: 'd.mts'
};
const disabledWarnings = new Set([
    'EMPTY_BUNDLE',
    'MIXED_EXPORTS',
    'PREFER_NAMED_EXPORTS',
    'UNRESOLVED_IMPORT',
    'THIS_IS_UNDEFINED',
    'INVALID_ANNOTATION',
    'UNUSED_EXTERNAL_IMPORT'
]);
const tsExtensions = new Set([
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const DEFAULT_TS_CONFIG = {
    compilerOptions: {
        module: 'ESNext',
        moduleResolution: 'bundler'
    }
};
const BINARY_TAG = '$binary';

function exit(err) {
    logger.error(err);
    process.exit(1);
}
async function getPackageMeta(cwd) {
    const pkgFilePath = path__default.default.resolve(cwd, 'package.json');
    let targetPackageJson = {};
    try {
        targetPackageJson = JSON.parse(await fsp__default.default.readFile(pkgFilePath, {
            encoding: 'utf-8'
        }));
    } catch (_) {}
    return targetPackageJson;
}
function isTypescriptFile(filename) {
    const ext = path__default.default.extname(filename).slice(1);
    return tsExtensions.has(ext);
}
function fileExists(filePath) {
    return fs__default.default.existsSync(filePath);
}
const isNotNull = (n)=>Boolean(n);
function resolveSourceFile(cwd, filename) {
    return path__default.default.resolve(cwd, SRC, filename);
}
function findSourceEntryFile(cwd, exportPath, exportTypeSuffix, ext) {
    const filename = resolveSourceFile(cwd, `${exportPath}${exportTypeSuffix ? `.${exportTypeSuffix}` : ''}.${ext}`);
    if (fileExists(filename)) {
        return filename;
    }
    const subFolderIndexFilename = resolveSourceFile(cwd, `${exportPath}/index${exportTypeSuffix ? `.${exportTypeSuffix}` : ''}.${ext}`);
    try {
        if (fileExists(subFolderIndexFilename)) {
            return subFolderIndexFilename;
        }
    } catch  {}
    return undefined;
}
// Map '.' -> './index.[ext]'
// Map './lite' -> './lite.[ext]'
// Return undefined if no match or if it's package.json exports
async function getSourcePathFromExportPath(cwd, exportPath, exportType) {
    for (const ext of availableExtensions){
        // ignore package.json
        if (exportPath === '/package.json') return;
        if (exportPath === '.') exportPath = './index';
        // Find convention-based source file for specific export types
        // $binary represents `pkg.bin`
        if (runtimeExportConventions.has(exportType) && exportType !== BINARY_TAG) {
            const filename = await findSourceEntryFile(cwd, exportPath, exportType, ext);
            if (filename) return filename;
        }
        const [, optimizeType] = exportType.split('.');
        if (optimizeConventions.has(optimizeType)) {
            const filename = await findSourceEntryFile(cwd, exportPath, optimizeType, ext);
            if (filename) return filename;
        }
        const filename = await findSourceEntryFile(cwd, exportPath, null, ext);
        if (filename) return filename;
    }
    return;
}
// TODO: add unit test
// Unlike path.basename, forcedly removing extension
function filePathWithoutExtension(filePath) {
    if (!filePath) return;
    const lastDotIndex = filePath.lastIndexOf('.');
    const lastSlashIndex = filePath.lastIndexOf('/');
    if (lastDotIndex !== -1 && lastDotIndex > lastSlashIndex) {
        return filePath.slice(0, filePath.indexOf('.', lastSlashIndex + 1));
    }
    return filePath;
}
const hasCjsExtension = (filename)=>path__default.default.extname(filename) === '.cjs';
const getMainFieldExportType = (pkg)=>{
    const isEsmPkg = isESModulePackage(pkg.type);
    const mainExportType = isEsmPkg && pkg.main ? hasCjsExtension(pkg.main) ? 'require' : 'import' : 'require';
    return mainExportType;
};
// TODO: add unit test
const baseNameWithoutExtension = (filename)=>path__default.default.basename(filename, path__default.default.extname(filename));
const isTestFile = (filename)=>/\.(test|spec)$/.test(baseNameWithoutExtension(filename));
function joinRelativePath(...segments) {
    let result = path__default.default.join(...segments);
    // If the first segment starts with '.', ensure the result does too.
    if (segments[0] === '.' && !result.startsWith('.')) {
        result = './' + result;
    }
    return result;
}
function isESModulePackage(packageType) {
    return packageType === 'module';
}
async function removeDir(dirPath) {
    try {
        const dirStat = await fsp__default.default.stat(dirPath);
        if (dirStat.isDirectory()) {
            await fsp__default.default.rm(dirPath, {
                recursive: true,
                force: true
            });
        }
    } catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
}
const removedDirs = new Set();
async function removeOutputDir(output, cwd) {
    const dir = output.dir;
    if (dir && // not equal to cwd
    dir !== cwd && // not equal to src/ dir
    dir !== path__default.default.resolve(cwd, SRC) && !removedDirs.has(dir)) {
        await removeDir(dir);
        removedDirs.add(dir);
    }
}
function isBinExportPath(exportPath) {
    return exportPath === BINARY_TAG || exportPath.startsWith(BINARY_TAG + '/');
}

function collectExportPath(exportValue, exportKey, currentPath, exportTypes, exportToDist) {
    // End of searching, export value is file path.
    // <export key>: <export value> (string)
    if (typeof exportValue === 'string') {
        const composedTypes = new Set(exportTypes);
        const exportType = exportKey.startsWith('.') ? 'default' : exportKey;
        composedTypes.add(exportType);
        const exportInfo = exportToDist.get(mapExportFullPath(currentPath));
        const exportCondition = Array.from(composedTypes).join('.');
        if (!exportInfo) {
            const outputConditionPair = [
                exportValue,
                exportCondition
            ];
            addToExportDistMap(exportToDist, currentPath, [
                outputConditionPair
            ], runtimeExportConventions.has(exportType) ? exportType : undefined);
        } else {
            exportInfo.push([
                exportValue,
                exportCondition
            ]);
        }
        return;
    }
    const exportKeys = Object.keys(exportValue);
    for (const exportKey of exportKeys){
        // Clone the set to avoid modifying the parent set
        const childExports = new Set(exportTypes);
        // Normalize child export value to a map
        const childExportValue = exportValue[exportKey];
        // Visit export path: ./subpath, ./subpath2, ...
        if (exportKey.startsWith('.')) {
            const childPath = joinRelativePath(currentPath, exportKey);
            collectExportPath(childExportValue, exportKey, childPath, childExports, exportToDist);
        } else {
            // Visit export type: import, require, ...
            childExports.add(exportKey);
            collectExportPath(childExportValue, exportKey, currentPath, childExports, exportToDist);
        }
    }
}
const mapExportFullPath = (exportPath)=>exportPath === '.' ? './index' : exportPath;
function addToExportDistMap(exportToDist, exportPath, outputConditionPairs, specialExportType) {
    const fullPath = mapExportFullPath(exportPath);
    // + (specialExportType ? '.' + specialExportType : '')
    const existingExportInfo = exportToDist.get(fullPath);
    if (!existingExportInfo) {
        exportToDist.set(fullPath, outputConditionPairs);
    } else {
        existingExportInfo.push(...outputConditionPairs);
    }
}
/**
 * parseExports - parse package.exports field and other fields like main,module to a map
 *
 * map from export path to output path and export conditions
 *
 * exportToDist: {
 *  './index': { development: ..., default: ... }
 *  './index.react-server': { development: ..., default: ... }
 * }
 */ function parseExports(pkg) {
    var _pkg_exports;
    const exportsField = (_pkg_exports = pkg.exports) != null ? _pkg_exports : {};
    var _pkg_bin;
    const bins = (_pkg_bin = pkg.bin) != null ? _pkg_bin : {};
    const exportToDist = new Map();
    const isEsmPkg = isESModulePackage(pkg.type);
    const defaultCondition = isEsmPkg ? 'import' : 'require';
    let currentPath = '.';
    if (typeof exportsField === 'string') {
        const outputConditionPair = [
            exportsField,
            defaultCondition
        ];
        addToExportDistMap(exportToDist, currentPath, [
            outputConditionPair
        ]);
    } else {
        // keys means unknown if they're relative path or export type
        const exportConditionKeys = Object.keys(exportsField);
        for (const exportKey of exportConditionKeys){
            const exportValue = exportsField[exportKey];
            const exportTypes = new Set();
            const isExportPath = exportKey.startsWith('.');
            const childPath = isExportPath ? joinRelativePath(currentPath, exportKey) : currentPath;
            if (!isExportPath) {
                exportTypes.add(exportKey);
            }
            collectExportPath(exportValue, exportKey, childPath, exportTypes, exportToDist);
        }
    }
    if (typeof bins === 'string') {
        const outputConditionPair = [
            bins,
            defaultCondition
        ];
        addToExportDistMap(exportToDist, BINARY_TAG, [
            outputConditionPair
        ]);
    } else {
        for (const binName of Object.keys(bins)){
            const binDistPath = bins[binName];
            const exportType = getExportTypeFromFile(binDistPath, pkg.type);
            const exportPath = path.posix.join(BINARY_TAG, binName);
            const outputConditionPair = [
                binDistPath,
                exportType
            ];
            addToExportDistMap(exportToDist, exportPath, [
                outputConditionPair
            ]);
        }
    }
    // Handle package.json global exports fields
    if (pkg.main || pkg.module || pkg.types) {
        const mainExportPath = pkg.main;
        const moduleExportPath = pkg.module;
        const typesEntryPath = pkg.types;
        addToExportDistMap(exportToDist, './index', [
            Boolean(mainExportPath) && [
                mainExportPath,
                getMainFieldExportType(pkg)
            ],
            Boolean(moduleExportPath) && [
                moduleExportPath,
                'module'
            ],
            Boolean(typesEntryPath) && [
                typesEntryPath,
                'types'
            ]
        ].filter(Boolean));
    }
    return exportToDist;
}
function isEsmExportName(name, ext) {
    return [
        'import',
        'module'
    ].includes(name) || ext === 'mjs';
}
function isCjsExportName(pkg, exportCondition, ext) {
    const isESModule = isESModulePackage(pkg.type);
    const isCjsCondition = [
        'require',
        'main'
    ].includes(exportCondition);
    const isNotEsmExportName = !isEsmExportName(exportCondition, ext);
    return !isESModule && isNotEsmExportName && (ext !== 'mjs' || isCjsCondition) || ext === 'cjs';
}
function getFileExportType(composedTypes) {
    return composedTypes.split('.').pop();
}
function getExportsDistFilesOfCondition(pkg, parsedExportCondition, cwd, dts) {
    const dist = [];
    const exportConditionNames = Object.keys(parsedExportCondition.export);
    const uniqueFiles = new Set();
    for (const exportCondition of exportConditionNames){
        const exportType = getFileExportType(exportCondition);
        // Filter out non-types field when generating types jobs
        if (dts && exportType !== 'types') {
            continue;
        }
        // Filter out types field when generating asset jobs
        if (!dts && exportType === 'types') {
            continue;
        }
        const filePath = parsedExportCondition.export[exportCondition];
        const ext = path.extname(filePath).slice(1);
        const relativePath = parsedExportCondition.export[exportCondition];
        const distFile = path.resolve(cwd, relativePath);
        const format = isCjsExportName(pkg, exportCondition, ext) ? 'cjs' : 'esm';
        if (uniqueFiles.has(distFile)) {
            continue;
        }
        uniqueFiles.add(distFile);
        dist.push({
            format,
            file: distFile,
            exportCondition
        });
    }
    return dist;
}
function getExportFileTypePath(absoluteJsBundlePath) {
    const dirName = path.dirname(absoluteJsBundlePath);
    const baseName = baseNameWithoutExtension(absoluteJsBundlePath);
    const ext = path.extname(absoluteJsBundlePath).slice(1);
    const typeExtension = dtsExtensionsMap[ext];
    return path.join(dirName, baseName + '.' + typeExtension);
}
function getExportTypeFromFile(filename, pkgType) {
    const isESModule = isESModulePackage(pkgType);
    const isCjsExt = filename.endsWith('.cjs');
    const isEsmExt = filename.endsWith('.mjs');
    const exportType = isEsmExt ? 'import' : isCjsExt ? 'require' : isESModule ? 'import' : 'require';
    return exportType;
}

function relativify(path) {
    return path.startsWith('.') ? path : `./${path}`;
}

// shared.ts -> ./shared
// shared.<export condition>.ts -> ./shared
// index.ts -> ./index
// index.development.ts -> ./index.development
function sourceFilenameToExportFullPath(filename) {
    const baseName = baseNameWithoutExtension(filename);
    let exportPath = baseName;
    return relativify(exportPath);
}
async function collectEntriesFromParsedExports(cwd, parsedExportsInfo, sourceFile) {
    const entries = {};
    if (sourceFile) {
        const defaultExport = parsedExportsInfo.get('./index')[0];
        entries['./index'] = {
            source: sourceFile,
            name: '.',
            export: {
                default: defaultExport[0]
            }
        };
    }
    // Find source files
    const { bins, exportsEntries } = await collectSourceEntriesFromExportPaths(path.join(cwd, SRC), parsedExportsInfo);
    // A mapping between each export path and its related special export conditions,
    // excluding the 'default' export condition.
    // { './index' => Set('development', 'edge-light') }
    const pathSpecialConditionsMap = {};
    for (const [exportPath] of exportsEntries){
        const normalizedExportPath = stripSpecialCondition(exportPath);
        if (!pathSpecialConditionsMap[normalizedExportPath]) {
            pathSpecialConditionsMap[normalizedExportPath] = new Set();
        }
        const exportType = getExportTypeFromExportPath(exportPath);
        if (exportType !== 'default') {
            pathSpecialConditionsMap[normalizedExportPath].add(exportType);
        }
    }
    // Traverse source files and try to match the entries
    // Find exports from parsed exports info
    // entryExportPath can be: './index', './index.development', './shared.edge-light', etc.
    for (const [entryExportPath, sourceFilesMap] of exportsEntries){
        const normalizedExportPath = stripSpecialCondition(entryExportPath);
        const entryExportPathType = getExportTypeFromExportPath(entryExportPath);
        const outputExports = parsedExportsInfo.get(normalizedExportPath);
        if (!outputExports) {
            continue;
        }
        for (const [outputPath, outputComposedExportType] of outputExports){
            // export type can be: default, development, react-server, etc.
            const matchedExportType = getSpecialExportTypeFromComposedExportPath(outputComposedExportType);
            const specialSet = pathSpecialConditionsMap[normalizedExportPath];
            const hasSpecialEntry = specialSet.has(matchedExportType);
            const sourceFile = sourceFilesMap[matchedExportType] || sourceFilesMap.default;
            if (!sourceFile) {
                continue;
            }
            if (!entries[entryExportPath]) {
                entries[entryExportPath] = {
                    source: sourceFile,
                    name: normalizedExportPath,
                    export: {}
                };
            } else if (matchedExportType === entryExportPathType) {
                entries[entryExportPath].source = sourceFile;
            }
            // output exports match
            if (matchedExportType === entryExportPathType || !hasSpecialEntry && matchedExportType !== 'default') {
                // When we dealing with special export conditions, we need to make sure
                // the outputs won't override the default export output paths.
                // e.g. We have './index' -> { default: 'index.js', development: 'index.development.js' };
                // When we generate './index.react-server' -> { 'react-server': 'index.react-server.js' },
                // Normalize the entryExportPath to './index' first and check if it already exists with output paths.
                const normalizedEntryExportPath = stripSpecialCondition(entryExportPath);
                if (// The entry already exists, e.g. normalize './index.react-server' to './index'
                entries[normalizedEntryExportPath] && // Is special export condition
                entryExportPathType !== 'default' && // The extracted special condition is not the current loop one.
                entryExportPathType !== matchedExportType) {
                    continue;
                }
                const exportMap = entries[entryExportPath].export;
                exportMap[outputComposedExportType] = outputPath;
            }
        }
    }
    // Handling binaries
    for (const [exportPath, sourceFile] of bins){
        const outputExports = parsedExportsInfo.get(exportPath);
        if (!outputExports) {
            continue;
        }
        for (const [outputPath, exportType] of outputExports){
            entries[exportPath] = {
                source: sourceFile,
                name: exportPath,
                export: {
                    [exportType]: outputPath
                }
            };
        }
    }
    return entries;
}
// ./index -> default
// ./index.development -> development
// ./index.react-server -> react-server
function getExportTypeFromExportPath(exportPath) {
    // Skip the first two segments: `.` and `index`
    const exportTypes = exportPath.split('.').slice(2);
    return getExportTypeFromExportTypesArray(exportTypes);
}
function getSpecialExportTypeFromComposedExportPath(composedExportType) {
    const exportTypes = composedExportType.split('.');
    for (const exportType of exportTypes){
        if (specialExportConventions.has(exportType)) {
            return exportType;
        }
    }
    return 'default';
}
function getExportTypeFromExportTypesArray(types) {
    let exportType = 'default';
    new Set(types).forEach((value)=>{
        if (specialExportConventions.has(value)) {
            exportType = value;
        } else if (value === 'import' || value === 'require' || value === 'types') {
            exportType = value;
        }
    });
    return exportType;
}
function getSpecialExportTypeFromConditionNames(conditionNames) {
    let exportType = 'default';
    conditionNames.forEach((value)=>{
        if (specialExportConventions.has(value)) {
            exportType = value;
        }
    });
    return exportType;
}
// ./index -> .
// ./index.development -> .
// ./index.react-server -> .
// ./shared -> ./shared
// ./shared.development -> ./shared
// $binary -> $binary
// $binary/index -> $binary
// $binary/foo -> $binary/foo
function normalizeExportPath(exportPath) {
    if (exportPath.startsWith(BINARY_TAG)) {
        if (exportPath === `${BINARY_TAG}/index`) {
            exportPath = BINARY_TAG;
        }
        return exportPath;
    }
    const baseName = exportPath.split('.').slice(0, 2).join('.');
    if (baseName === './index') {
        return '.';
    }
    return baseName;
}
// ./index.react-server -> ./index
function stripSpecialCondition(exportPath) {
    return exportPath.split('.').slice(0, 2).join('.');
}
async function collectSourceEntriesByExportPath(sourceFolderPath, originalSubpath, bins, exportsEntries) {
    const isBinaryPath = isBinExportPath(originalSubpath);
    const subpath = originalSubpath.replace(BINARY_TAG, 'bin');
    const absoluteDirPath = path__default.default.join(sourceFolderPath, subpath);
    const isDirectory = fs__default.default.existsSync(absoluteDirPath) ? (await fsp__default.default.stat(absoluteDirPath)).isDirectory() : false;
    if (isDirectory) {
        if (isBinaryPath) {
            const binDirentList = await fsp__default.default.readdir(absoluteDirPath, {
                withFileTypes: true
            });
            for (const binDirent of binDirentList){
                if (binDirent.isFile()) {
                    const binFileAbsolutePath = path__default.default.join(absoluteDirPath, binDirent.name);
                    if (fs__default.default.existsSync(binFileAbsolutePath)) {
                        bins.set(normalizeExportPath(originalSubpath), binFileAbsolutePath);
                    }
                }
            }
        } else {
            // Search folder/index.<ext> convention entries
            for (const extension of availableExtensions){
                const indexAbsoluteFile = path__default.default.join(absoluteDirPath, `index.${extension}`);
                // Search folder/index.<special type>.<ext> convention entries
                for (const specialExportType of runtimeExportConventions){
                    const indexSpecialAbsoluteFile = path__default.default.join(absoluteDirPath, `index.${specialExportType}.${extension}`);
                    if (fs__default.default.existsSync(indexSpecialAbsoluteFile)) {
                        // Add special export path
                        // { ./<export path>.<special cond>: { <special cond>: 'index.<special cond>.<ext>' } }
                        const exportPath = relativify(subpath);
                        const specialExportPath = exportPath + '.' + specialExportType;
                        const sourceFilesMap = exportsEntries.get(specialExportPath) || {};
                        sourceFilesMap[specialExportType] = indexSpecialAbsoluteFile;
                        exportsEntries.set(specialExportPath, sourceFilesMap);
                    }
                }
                if (fs__default.default.existsSync(indexAbsoluteFile) && !isTestFile(indexAbsoluteFile)) {
                    const exportPath = relativify(subpath);
                    const sourceFilesMap = exportsEntries.get(exportPath) || {};
                    const exportType = getExportTypeFromExportPath(exportPath);
                    sourceFilesMap[exportType] = indexAbsoluteFile;
                    exportsEntries.set(exportPath, sourceFilesMap);
                }
            }
        }
    } else {
        // subpath could be a file
        const dirName = path.dirname(subpath);
        const baseName = path.basename(subpath);
        // Read current file's directory
        const dirPath = path__default.default.join(sourceFolderPath, dirName);
        if (!fs__default.default.existsSync(dirPath)) {
            return;
        }
        const dirents = await fsp__default.default.readdir(dirPath, {
            withFileTypes: true
        });
        for (const dirent of dirents){
            // index.development.js -> index.development
            const direntBaseName = baseNameWithoutExtension(dirent.name);
            const ext = path.extname(dirent.name).slice(1);
            if (!dirent.isFile() || direntBaseName !== baseName || !availableExtensions.has(ext)) {
                continue;
            }
            if (isTestFile(dirent.name)) {
                continue;
            }
            const sourceFileAbsolutePath = path__default.default.join(dirPath, dirent.name);
            if (isBinaryPath) {
                bins.set(originalSubpath, sourceFileAbsolutePath);
            } else {
                let sourceFilesMap = exportsEntries.get(originalSubpath) || {};
                const exportType = getExportTypeFromExportPath(originalSubpath);
                sourceFilesMap[exportType] = sourceFileAbsolutePath;
                if (specialExportConventions.has(exportType)) {
                    // e.g. ./foo/index.react-server -> ./foo/index
                    const fallbackExportPath = sourceFilenameToExportFullPath(originalSubpath);
                    const fallbackSourceFilesMap = exportsEntries.get(fallbackExportPath) || {};
                    sourceFilesMap = {
                        ...fallbackSourceFilesMap,
                        ...sourceFilesMap
                    };
                }
                exportsEntries.set(originalSubpath, sourceFilesMap);
            }
        }
    }
}
/**
 * exportsEntries {
 *   "./index" => {
 *      "development" => source"
 *      "react-server" => "source"
 *   },
 *  "./index.react-server" => {
 *      "development" => source"
 *      "react-server" => "source"
 *   }
 *  }
 */ async function collectSourceEntriesFromExportPaths(sourceFolderPath, parsedExportsInfo) {
    const bins = new Map();
    const exportsEntries = new Map();
    for (const [exportPath, exportInfo] of parsedExportsInfo.entries()){
        const specialConditions = new Set();
        for (const [_, composedExportType] of exportInfo){
            const specialExportType = getSpecialExportTypeFromComposedExportPath(composedExportType);
            if (specialExportType !== 'default') {
                specialConditions.add(specialExportType);
            }
        }
        await collectSourceEntriesByExportPath(sourceFolderPath, exportPath, bins, exportsEntries);
        for (const specialCondition of specialConditions){
            await collectSourceEntriesByExportPath(sourceFolderPath, exportPath + '.' + specialCondition, bins, exportsEntries);
        }
    }
    return {
        bins,
        exportsEntries
    };
}

// Example: @foo/bar -> bar
const removeScope = (exportPath)=>exportPath.replace(/^@[^/]+\//, '');
function createOutputState({ entries }) {
    const sizeStats = new Map();
    const uniqFiles = new Set();
    function addSize({ fileName, size, sourceFileName, exportPath }) {
        if (!sizeStats.has(exportPath)) {
            sizeStats.set(exportPath, []);
        }
        const distFilesStats = sizeStats.get(exportPath);
        if (!uniqFiles.has(fileName)) {
            uniqFiles.add(fileName);
            if (distFilesStats) {
                distFilesStats.push([
                    fileName,
                    sourceFileName,
                    size
                ]);
            }
        }
    }
    const reversedMapping = new Map();
    Object.entries(entries).forEach(([resolvedExportName, entry])=>{
        reversedMapping.set(entry.source, resolvedExportName);
    });
    return {
        plugin: (cwd)=>{
            return {
                name: 'collect-sizes',
                writeBundle (options, bundle) {
                    const dir = options.dir || path.posix.dirname(options.file);
                    Object.entries(bundle).forEach(([fileName, chunk])=>{
                        const filePath = path.posix.join(dir, fileName);
                        if (chunk.type !== 'chunk') {
                            return;
                        }
                        if (!chunk.isEntry) {
                            return;
                        }
                        const size = chunk.code.length;
                        const sourceFileName = chunk.facadeModuleId || '';
                        const exportPath = removeScope(reversedMapping.get(sourceFileName) || '.');
                        addSize({
                            fileName: path__default.default.isAbsolute(cwd) ? path.posix.relative(cwd, filePath) : filePath,
                            size,
                            sourceFileName,
                            exportPath
                        });
                    });
                }
            };
        },
        getSizeStats () {
            return sizeStats;
        }
    };
}

const memoize = (fn, cacheKey, cacheArg)=>{
    const cache = cacheArg || new Map();
    return (...args)=>{
        const key = cacheKey ? typeof cacheKey === 'function' ? cacheKey(...args) : cacheKey : JSON.stringify({
            args
        });
        const existing = cache.get(key);
        if (existing !== undefined) {
            return existing;
        }
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
};
const memoizeByKey = (fn)=>{
    const cache = new Map();
    return (cacheKey)=>memoize(fn, cacheKey, cache);
};

let hasLoggedTsWarning = false;
function resolveTypescript(cwd) {
    let ts;
    const m = new module$1.Module('', undefined);
    m.paths = module$1.Module._nodeModulePaths(cwd);
    try {
        // Bun does not yet support the `Module` class properly.
        if (typeof (m == null ? void 0 : m.require) === 'undefined') {
            const tsPath = require.resolve('typescript', {
                paths: [
                    cwd
                ]
            });
            ts = require(tsPath);
        } else {
            ts = m.require('typescript');
        }
    } catch (e) {
        console.error(e);
        if (!hasLoggedTsWarning) {
            hasLoggedTsWarning = true;
            exit('Could not load TypeScript compiler. Try to install `typescript` as dev dependency');
        }
    }
    return ts;
}
function resolveTsConfigHandler(cwd, tsconfig = 'tsconfig.json') {
    let tsCompilerOptions = {};
    let tsConfigPath;
    tsConfigPath = path.resolve(cwd, tsconfig);
    if (fileExists(tsConfigPath)) {
        // Use the original ts handler to avoid memory leak
        const ts = resolveTypescript(cwd);
        const basePath = tsConfigPath ? path.dirname(tsConfigPath) : cwd;
        const tsconfigJSON = ts.readConfigFile(tsConfigPath, ts.sys.readFile).config;
        tsCompilerOptions = ts.parseJsonConfigFileContent(tsconfigJSON, ts.sys, basePath).options;
    } else {
        return null;
    }
    return {
        tsCompilerOptions,
        tsConfigPath
    };
}
const resolveTsConfig = memoizeByKey(resolveTsConfigHandler)();
async function convertCompilerOptions(cwd, json) {
    // Use the original ts handler to avoid memory leak
    const ts = resolveTypescript(cwd);
    return ts.convertCompilerOptionsFromJson(json, './');
}
async function writeDefaultTsconfig(tsConfigPath) {
    await fs.promises.writeFile(tsConfigPath, JSON.stringify(DEFAULT_TS_CONFIG, null, 2), 'utf-8');
    logger.log(`Detected using TypeScript but tsconfig.json is missing, created a ${pc.blue('tsconfig.json')} for you.`);
}

/**
 * @return {Record<string, string>} env { 'process.env.<key>': '<value>' }
 */ function getDefinedInlineVariables(envs, parsedExportCondition) {
    if (!envs.includes('NODE_ENV')) {
        envs.push('NODE_ENV');
    }
    const envVars = envs.reduce((acc, key)=>{
        const value = process.env[key];
        if (typeof value !== 'undefined') {
            acc['process.env.' + key] = JSON.stringify(value);
        }
        return acc;
    }, {});
    const exportConditionNames = Object.keys(parsedExportCondition.export).reduce((acc, key)=>{
        // key could be 'require' or 'import.development' etc.
        const exportTypes = key.split('.');
        for (const exportType of exportTypes){
            acc.add(exportType);
        }
        return acc;
    }, new Set());
    // For development and production convention, we override the NODE_ENV value
    if (exportConditionNames.has('development')) {
        envVars['process.env.NODE_ENV'] = JSON.stringify('development');
    } else if (exportConditionNames.has('production')) {
        envVars['process.env.NODE_ENV'] = JSON.stringify('production');
    }
    if (exportConditionNames.has('edge-light')) {
        envVars['EdgeRuntime'] = JSON.stringify('edge-runtime');
    }
    return envVars;
}

const FILENAME_REGEX = /__filename/;
const DIRNAME_REGEX = /__dirname/;
// not char, or space before require(.resolve)?(
const GLOBAL_REQUIRE_REGEX = /[\W\s]require(\.resolve)?\(/;
const PolyfillComment = '/** rollup-private-do-not-use-esm-shim-polyfill */';
const createESMShim = ({ filename, dirname, globalRequire })=>{
    const useNodeUrl = filename || dirname;
    const useNodePath = dirname;
    const useNodeModule = globalRequire;
    return `\
${PolyfillComment}
${useNodeUrl ? `import __node_cjsUrl from 'node:url'` : ''};
${useNodePath ? `import __node_cjsPath from 'node:path';` : ''}
${useNodeModule ? `import __node_cjsModule from 'node:module';` : ''}
${useNodeUrl ? 'const __filename = __node_cjsUrl.fileURLToPath(import.meta.url);' : ''}
${useNodePath ? 'const __dirname = __node_cjsPath.dirname(__filename);' : ''}
${useNodeModule ? 'const require = __node_cjsModule.createRequire(import.meta.url);' : ''}
`.trim() + '\n';
};
function esmShim() {
    return {
        name: 'esm-shim',
        transform: {
            order: 'post',
            handler (code, id) {
                const ext = path.extname(id);
                if (!availableESExtensionsRegex.test(ext) || code.includes(PolyfillComment)) {
                    return null;
                }
                let hasFilename = false;
                let hasDirname = false;
                let hasGlobalRequire = false;
                if (FILENAME_REGEX.test(code)) {
                    hasFilename = true;
                }
                if (DIRNAME_REGEX.test(code)) {
                    hasDirname = true;
                }
                if (GLOBAL_REQUIRE_REGEX.test(code)) {
                    hasGlobalRequire = true;
                }
                if (!hasFilename && !hasDirname && !hasGlobalRequire) {
                    return null;
                }
                const magicString = new MagicString__default.default(code);
                let ast = null;
                try {
                    // rollup 2 built-in parser doesn't have `allowShebang`, we need to use the sliced code here. Hence the `magicString.toString()`
                    ast = this.parse(magicString.toString(), {
                        allowReturnOutsideFunction: true
                    });
                } catch (e) {
                    console.warn(e);
                    return null;
                }
                if (ast.type !== 'Program') {
                    return null;
                }
                let lastImportNode = null;
                for (const node of ast.body){
                    if (node.type === 'ImportDeclaration') {
                        lastImportNode = node;
                        continue;
                    }
                }
                let end = 0;
                if (lastImportNode) {
                    end = lastImportNode.end;
                } else {
                    end = ast.body.length > 0 ? ast.body[0].end : 0;
                }
                magicString.appendRight(end, '\n' + createESMShim({
                    filename: hasFilename,
                    dirname: hasDirname,
                    globalRequire: hasGlobalRequire
                }));
                return {
                    code: magicString.toString(),
                    map: magicString.generateMap({
                        hires: true
                    })
                };
            }
        }
    };
}

const helpers = {
    cssImport: {
        // have to assign r.type = 'text/css' to make it work in Safari
        global: `\
function __insertCSS(code) {
  if (!code || typeof document == 'undefined') return
  let head = document.head || document.getElementsByTagName('head')[0]
  let style = document.createElement('style')
  style.type = 'text/css'
  head.appendChild(style)
  ;style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))
}
`,
        create (code) {
            return `__insertCSS(${JSON.stringify(code)});`;
        }
    },
    cssAssertionImport: {
        global: '',
        create (code) {
            return `\
const sheet = new CSSStyleSheet()
sheet.replaceSync(${JSON.stringify(code)})
export default sheet`;
        }
    }
};
const cleanCssInstance = new CleanCSS__default.default({});
function minify(code) {
    return cleanCssInstance.minify(code).styles;
}
function inlineCss(options) {
    const cssIds = new Set();
    var _options_exclude;
    const filter = pluginutils.createFilter([
        '**/*.css'
    ], (_options_exclude = options.exclude) != null ? _options_exclude : []);
    // Follow up for rollup 4 for better support of assertion support https://github.com/rollup/rollup/issues/4818
    return {
        name: 'inline-css',
        transform: {
            order: 'post',
            handler (code, id) {
                if (!filter(id)) return;
                if (options.skip) return '';
                const cssCode = minify(code);
                cssIds.add(id);
                return {
                    code: helpers.cssImport.create(cssCode),
                    map: {
                        mappings: ''
                    }
                };
            }
        },
        renderChunk: {
            order: 'pre',
            handler (code) {
                const dependenciesIds = this.getModuleIds();
                let foundCss = false;
                for (const depId of dependenciesIds){
                    if (depId && cssIds.has(depId)) {
                        foundCss = true;
                        break;
                    }
                }
                if (!foundCss) return;
                return {
                    code: `${helpers.cssImport.global}\n${code}`,
                    map: {
                        mappings: ''
                    }
                };
            }
        }
    };
}

function rawContent({ exclude }) {
    const filter = pluginutils.createFilter([
        '**/*.data',
        '**/*.txt'
    ], exclude);
    return {
        name: 'string',
        transform (code, id) {
            if (filter(id)) {
                return {
                    code: `const data = ${JSON.stringify(code)};\nexport default data;`,
                    map: null
                };
            }
            return null;
        }
    };
}

function hasNoSpecialCondition(conditionNames) {
    return [
        ...conditionNames
    ].every((name)=>!specialExportConventions.has(name));
}
function findJsBundlePathCallback({ format, bundlePath, conditionNames }, specialCondition) {
    const hasBundle = bundlePath != null;
    const formatCond = format === 'cjs' ? 'require' : 'import';
    const isTypesCondName = conditionNames.has('types');
    const hasFormatCond = conditionNames.has('import') || conditionNames.has('require');
    const isMatchedFormat = hasFormatCond ? conditionNames.has(formatCond) : true;
    const isMatchedConditionWithFormat = conditionNames.has(specialCondition) || !conditionNames.has('default') && hasNoSpecialCondition(conditionNames);
    return isMatchedConditionWithFormat && !isTypesCondName && hasBundle && isMatchedFormat;
}
function findTypesFileCallback({ format, bundlePath, conditionNames }) {
    const hasCondition = bundlePath != null;
    const formatCond = format ? format === 'cjs' ? 'require' : 'import' : null;
    const isTypesCondName = conditionNames.has('types');
    return isTypesCondName && hasCondition && (formatCond ? conditionNames.has(formatCond) : true);
}
// Alias entry key to dist bundle path
function aliasEntries({ entry: sourceFilePath, conditionNames, entries, format, dts, cwd }) {
    // <imported source file path>: <relative path to source's bundle>
    const sourceToRelativeBundleMap = new Map();
    const specialCondition = getSpecialExportTypeFromConditionNames(conditionNames);
    for (const [, exportCondition] of Object.entries(entries)){
        const exportDistMaps = exportCondition.export;
        const exportMapEntries = Object.entries(exportDistMaps).map(([composedKey, bundlePath])=>({
                conditionNames: new Set(composedKey.split('.')),
                bundlePath,
                format
            }));
        let matchedBundlePath;
        if (dts) {
            var _exportMapEntries_find;
            // Find the type with format condition first
            matchedBundlePath = (_exportMapEntries_find = exportMapEntries.find(findTypesFileCallback)) == null ? void 0 : _exportMapEntries_find.bundlePath;
            // If theres no format specific types such as import.types or require.types,
            // fallback to the general types file.
            if (!matchedBundlePath) {
                var _exportMapEntries_find1;
                matchedBundlePath = (_exportMapEntries_find1 = exportMapEntries.find((item)=>{
                    return findTypesFileCallback({
                        ...item,
                        format: undefined
                    });
                })) == null ? void 0 : _exportMapEntries_find1.bundlePath;
            }
        } else {
            var _exportMapEntries_find2;
            matchedBundlePath = (_exportMapEntries_find2 = exportMapEntries.find((item)=>{
                return findJsBundlePathCallback(item, specialCondition);
            })) == null ? void 0 : _exportMapEntries_find2.bundlePath;
        }
        if (matchedBundlePath) {
            if (!sourceToRelativeBundleMap.has(exportCondition.source)) sourceToRelativeBundleMap.set(exportCondition.source, matchedBundlePath);
        }
    }
    return {
        name: 'alias',
        resolveId: {
            async handler (source, importer, options) {
                const resolved = await this.resolve(source, importer, options);
                if (resolved != null) {
                    // For types, generate relative path to the other type files,
                    // this will be compatible for the node10 ts module resolution.
                    let srcBundle = sourceToRelativeBundleMap.get(sourceFilePath);
                    // Resolved module bundle path
                    let resolvedModuleBundle = sourceToRelativeBundleMap.get(resolved.id);
                    if (resolved.id !== sourceFilePath && srcBundle && resolvedModuleBundle) {
                        const absoluteBundlePath = path.posix.resolve(cwd, srcBundle);
                        const absoluteImportBundlePath = path.posix.resolve(cwd, resolvedModuleBundle);
                        const filePathBase = path.posix.relative(path.posix.dirname(absoluteBundlePath), absoluteImportBundlePath);
                        const relativePath = relativify(filePathBase);
                        return {
                            id: relativePath,
                            external: true
                        };
                    }
                }
                return null;
            }
        }
    };
}

function prependDirectives() {
    return {
        name: 'prependDirective',
        transform: {
            order: 'post',
            handler (code, id) {
                var _moduleInfo_meta;
                const moduleInfo = this.getModuleInfo(id);
                if (moduleInfo == null ? void 0 : (_moduleInfo_meta = moduleInfo.meta) == null ? void 0 : _moduleInfo_meta.preserveDirectives) {
                    const firstDirective = moduleInfo.meta.preserveDirectives.directives[0];
                    if (firstDirective) {
                        const directive = firstDirective.value;
                        const directiveCode = `'${directive}';`;
                        return directiveCode + '\n' + code;
                    }
                }
                return null;
            }
        }
    };
}

const prependShebang = (entry)=>({
        name: 'prependShebang',
        transform: (code, id)=>{
            if (id !== entry) return;
            const shebang = '#!/usr/bin/env node\n';
            if (code.startsWith(shebang)) return;
            const magicString = new MagicString__default.default(code);
            magicString.prepend(shebang);
            return {
                code: magicString.toString(),
                map: magicString.generateMap({
                    hires: true
                })
            };
        }
    });

const swcMinifyOptions = {
    compress: {
        directives: false
    },
    format: {
        comments: 'some'
    },
    mangle: {
        toplevel: true
    }
};
async function createDtsPlugin(tsCompilerOptions, tsConfigPath, respectExternal, cwd) {
    const enableIncrementalWithoutBuildInfo = tsCompilerOptions.incremental && !tsCompilerOptions.tsBuildInfoFile;
    const incrementalOptions = enableIncrementalWithoutBuildInfo ? {
        incremental: false
    } : undefined;
    const compositeOptions = tsCompilerOptions.composite ? {
        composite: false
    } : undefined;
    const { options: overrideResolvedTsOptions } = await convertCompilerOptions(cwd, {
        declaration: true,
        noEmit: false,
        noEmitOnError: true,
        emitDeclarationOnly: true,
        checkJs: false,
        declarationMap: false,
        skipLibCheck: true,
        // preserveSymlinks should always be set to false to avoid issues with
        // resolving types from <reference> from node_modules
        preserveSymlinks: false,
        target: 'ESNext',
        ...!tsCompilerOptions.jsx ? {
            jsx: 'react-jsx'
        } : undefined,
        // error TS5074: Option '--incremental' can only be specified using tsconfig, emitting to single
        // file or when option '--tsBuildInfoFile' is specified.
        ...incrementalOptions,
        // error TS6379: Composite projects may not disable incremental compilation.
        ...compositeOptions
    });
    const dtsPlugin = require('rollup-plugin-dts').default({
        tsconfig: tsConfigPath,
        compilerOptions: overrideResolvedTsOptions,
        respectExternal
    });
    return dtsPlugin;
}
const memoizeDtsPluginByKey = memoizeByKey(createDtsPlugin);
async function buildInputConfig(entry, bundleConfig, exportCondition, buildContext, dts) {
    var _bundleConfig_file, _bundleConfig_file1;
    const { entries, pkg, cwd, tsOptions: { tsConfigPath, tsCompilerOptions }, pluginContext } = buildContext;
    const isBinEntry = isBinExportPath(exportCondition.name);
    const hasNoExternal = bundleConfig.external === null;
    var _bundleConfig_external;
    const externals = hasNoExternal ? [] : [
        pkg.peerDependencies,
        pkg.dependencies,
        pkg.peerDependenciesMeta
    ].filter((n)=>Boolean(n)).map((o)=>Object.keys(o)).reduce((a, b)=>a.concat(b), []).concat((_bundleConfig_external = bundleConfig.external) != null ? _bundleConfig_external : []);
    for (const [exportImportPath, exportCondition] of Object.entries(entries)){
        const entryFilePath = exportCondition.source;
        if (entryFilePath !== entry) {
            externals.push(path.posix.join(pkg.name || '', normalizeExportPath(exportImportPath)));
            externals.push(entryFilePath);
        }
    }
    const inlineDefinedValues = getDefinedInlineVariables(bundleConfig.env || [], exportCondition);
    const { useTypeScript } = buildContext;
    const { runtime, target: jscTarget, minify: shouldMinify } = bundleConfig;
    const hasSpecifiedTsTarget = Boolean(tsCompilerOptions.target && tsConfigPath);
    const swcParserConfig = {
        syntax: useTypeScript ? 'typescript' : 'ecmascript',
        [useTypeScript ? 'tsx' : 'jsx']: true,
        exportDefaultFrom: true,
        decorators: true
    };
    const swcOptions = {
        jsc: {
            ...!hasSpecifiedTsTarget && {
                target: jscTarget
            },
            loose: true,
            externalHelpers: false,
            parser: swcParserConfig,
            transform: {
                decoratorVersion: '2022-03'
            },
            ...shouldMinify && {
                minify: {
                    ...swcMinifyOptions,
                    sourceMap: bundleConfig.sourcemap
                }
            }
        },
        sourceMaps: bundleConfig.sourcemap,
        inlineSourcesContent: false,
        isModule: true
    };
    const sizePlugin = pluginContext.outputState.plugin(cwd);
    // common plugins for both dts and ts assets that need to be processed
    // If it's a .d.ts file under non-ESM package or .d.cts file, use cjs types alias.
    const aliasFormat = dts ? ((_bundleConfig_file = bundleConfig.file) == null ? void 0 : _bundleConfig_file.endsWith('.d.cts')) || ((_bundleConfig_file1 = bundleConfig.file) == null ? void 0 : _bundleConfig_file1.endsWith('.d.ts')) && !isESModulePackage(pkg.type) ? 'cjs' : 'esm' : bundleConfig.format;
    const currentConditionNames = Object.keys(exportCondition.export)[0];
    const aliasPlugin = aliasEntries({
        entry,
        entries,
        format: aliasFormat,
        conditionNames: new Set(currentConditionNames.split('.')),
        dts,
        cwd
    });
    const commonPlugins = [
        json__default.default(),
        sizePlugin
    ];
    const typesPlugins = [
        aliasPlugin,
        ...commonPlugins,
        inlineCss({
            skip: true
        })
    ];
    if (useTypeScript) {
        // Each process should be unique
        // Each package build should be unique
        // Composing above factors into a unique cache key to retrieve the memoized dts plugin with tsconfigs
        const uniqueProcessId = 'dts-plugin:' + process.pid + tsConfigPath;
        const dtsPlugin = await memoizeDtsPluginByKey(uniqueProcessId)(tsCompilerOptions, tsConfigPath, bundleConfig.dts && bundleConfig.dts.respectExternal, cwd);
        typesPlugins.push(dtsPlugin);
    }
    const plugins = (dts ? typesPlugins : [
        ...commonPlugins,
        preserveDirectives__default.default(),
        aliasPlugin,
        inlineCss({
            exclude: /node_modules/
        }),
        rawContent({
            exclude: /node_modules/
        }),
        isBinEntry && prependShebang(entry),
        replace__default.default({
            values: inlineDefinedValues,
            preventAssignment: true
        }),
        pluginNodeResolve.nodeResolve({
            preferBuiltins: runtime === 'node',
            extensions: nodeResolveExtensions
        }),
        bundleConfig.format === 'esm' && esmShim(),
        pluginWasm.wasm(),
        rollupPluginSwc3.swc({
            include: availableESExtensionsRegex,
            exclude: 'node_modules',
            // Use `false` to disable retrieving tsconfig.json
            tsconfig: tsConfigPath != null ? tsConfigPath : false,
            ...swcOptions
        }),
        commonjs__default.default({
            exclude: bundleConfig.external || null
        }),
        prependDirectives()
    ]).filter(isNotNull);
    return {
        input: entry,
        external (id) {
            return externals.some((name)=>id === name || id.startsWith(name + '/'));
        },
        plugins,
        treeshake: {
            propertyReadSideEffects: false
        },
        onwarn (warning, warn) {
            const code = warning.code || '';
            // Some may not have types, like CLI binary
            if (dts && code === 'EMPTY_BUNDLE') return;
            if (disabledWarnings.has(code)) return;
            // If the circular dependency warning is from node_modules, ignore it
            if (code === 'CIRCULAR_DEPENDENCY' && /Circular dependency:(\s|\S)*node_modules/.test(warning.message)) {
                return;
            }
            if (code === 'MODULE_LEVEL_DIRECTIVE') {
                return;
            }
            warn(warning);
        }
    };
}

function getModuleLayer(moduleMeta) {
    const directives = (moduleMeta.preserveDirectives || {
        directives: []
    }).directives.map((d)=>d.replace(/^use /, '')).filter((d)=>d !== 'strict');
    const moduleLayer = directives[0];
    return moduleLayer;
}
function getCustomModuleLayer(moduleId) {
    const segments = path__default.default.basename(moduleId).split('.');
    if (segments.length >= 2) {
        const [layerSegment, ext] = segments.slice(-2);
        const baseName = segments[0];
        const match = layerSegment.match(/^(\w+)-runtime$/);
        const layer = match && match[1];
        if (availableExtensions.has(ext) && layer && layer.length > 0) {
            return baseName + '-' + layer;
        }
    }
    return undefined;
}
// dependencyGraphMap: Map<subModuleId, Set<entryParentId>>
function createSplitChunks(dependencyGraphMap, entryFiles) {
    // If there's existing chunk being splitted, and contains a layer { <id>: <chunkGroup> }
    const splitChunksGroupMap = new Map();
    return function splitChunks(id, ctx) {
        const moduleInfo = ctx.getModuleInfo(id);
        if (!moduleInfo) {
            return;
        }
        const { isEntry } = moduleInfo;
        const moduleMeta = moduleInfo.meta;
        const moduleLayer = getModuleLayer(moduleMeta);
        if (!isEntry) {
            const cachedCustomModuleLayer = splitChunksGroupMap.get(id);
            if (cachedCustomModuleLayer) return cachedCustomModuleLayer;
            const customModuleLayer = getCustomModuleLayer(id);
            if (customModuleLayer) {
                splitChunksGroupMap.set(id, customModuleLayer);
                return customModuleLayer;
            }
        }
        // Collect the sub modules of the entry, if they're having layer, and the same layer with the entry, push them to the dependencyGraphMap.
        if (isEntry) {
            const subModuleIds = ctx.getModuleIds();
            for (const subId of subModuleIds){
                const subModuleInfo = ctx.getModuleInfo(subId);
                if (!subModuleInfo) {
                    continue;
                }
                const subModuleLayer = getModuleLayer(moduleMeta);
                if (subModuleLayer === moduleLayer) {
                    if (!dependencyGraphMap.has(subId)) {
                        dependencyGraphMap.set(subId, new Set());
                    }
                    dependencyGraphMap.get(subId).add([
                        id,
                        moduleLayer
                    ]);
                }
            }
        }
        // If current module has a layer, and it's not an entry
        if (moduleLayer && !isEntry) {
            // If the module is imported by the entry:
            // when the module layer is same as entry layer, keep it as part of entry and don't split it;
            // when the module layer is different from entry layer, split the module into a separate chunk as a separate boundary.
            if (dependencyGraphMap.has(id)) {
                const parentModuleIds = Array.from(dependencyGraphMap.get(id));
                const isImportFromOtherEntry = parentModuleIds.some(([id])=>{
                    // If other entry is dependency of this entry
                    if (entryFiles.has(id)) {
                        const entryModuleInfo = ctx.getModuleInfo(id);
                        const entryModuleLayer = getModuleLayer(entryModuleInfo ? entryModuleInfo.meta : {});
                        return entryModuleLayer === moduleLayer;
                    }
                    return false;
                });
                if (isImportFromOtherEntry) return;
                const isPartOfCurrentEntry = parentModuleIds.every(([, layer])=>layer === moduleLayer);
                if (isPartOfCurrentEntry) {
                    if (splitChunksGroupMap.has(id)) {
                        return splitChunksGroupMap.get(id);
                    }
                    return;
                }
                const chunkName = path__default.default.basename(id, path__default.default.extname(id));
                const chunkGroup = `${chunkName}-${moduleLayer}`;
                splitChunksGroupMap.set(id, chunkGroup);
                return chunkGroup;
            }
        }
        return;
    };
}

async function buildOutputConfigs(bundleConfig, exportCondition, buildContext, dts) {
    const { format } = bundleConfig;
    const { entries, pkg, cwd, tsOptions: { tsCompilerOptions }, pluginContext } = buildContext;
    // Add esm mark and interop helper if esm export is detected
    const useEsModuleMark = tsCompilerOptions == null ? void 0 : tsCompilerOptions.esModuleInterop;
    const absoluteOutputFile = path.resolve(cwd, bundleConfig.file);
    const isEsmPkg = isESModulePackage(pkg.type);
    const name = filePathWithoutExtension(absoluteOutputFile);
    var _exportCondition_export_types;
    const dtsFile = path.resolve(cwd, dts ? bundleConfig.file : (_exportCondition_export_types = exportCondition.export.types) != null ? _exportCondition_export_types : getExportFileTypePath(bundleConfig.file));
    const typesDir = path.dirname(dtsFile);
    const jsDir = path.dirname(absoluteOutputFile);
    const outputFile = dts ? dtsFile : absoluteOutputFile;
    const entryFiles = new Set(Object.values(entries).map((entry)=>entry.source));
    const outputOptions = {
        name: pkg.name || name,
        dir: dts ? typesDir : jsDir,
        format,
        exports: 'named',
        esModule: useEsModuleMark || 'if-default-prop',
        interop: 'auto',
        freeze: false,
        strict: false,
        sourcemap: bundleConfig.sourcemap,
        manualChunks: createSplitChunks(pluginContext.moduleDirectiveLayerMap, entryFiles),
        chunkFileNames () {
            const isCjsFormat = format === 'cjs';
            const ext = dts ? 'd.ts' : isCjsFormat && isEsmPkg ? 'cjs' : !isCjsFormat && !isEsmPkg ? 'mjs' : 'js';
            return '[name]-[hash].' + ext;
        },
        // By default in rollup, when creating multiple chunks, transitive imports of entry chunks
        // will be added as empty imports to the entry chunks. Disable to avoid imports hoist outside of boundaries
        hoistTransitiveImports: false,
        entryFileNames: path.basename(outputFile)
    };
    return outputOptions;
}

async function buildEntryConfig(bundleConfig, pluginContext, bundleEntryOptions) {
    const configs = [];
    const { entries } = pluginContext;
    for (const exportCondition of Object.values(entries)){
        const rollupConfigs = await buildConfig(bundleConfig, exportCondition, pluginContext, bundleEntryOptions);
        configs.push(...rollupConfigs);
    }
    return configs;
}
async function buildRollupConfigs(entry, bundleConfig, exportCondition, buildContext, dts) {
    const inputOptions = await buildInputConfig(entry, bundleConfig, exportCondition, buildContext, dts);
    const outputOptions = await buildOutputConfigs(bundleConfig, exportCondition, buildContext, dts);
    return {
        input: inputOptions,
        output: outputOptions
    };
}
async function buildConfig(bundleConfig, exportCondition, pluginContext, bundleEntryOptions) {
    const { file } = bundleConfig;
    const { pkg, cwd } = pluginContext;
    const { dts, isFromCli } = bundleEntryOptions;
    const entry = exportCondition.source;
    const outputExports = getExportsDistFilesOfCondition(pkg, exportCondition, cwd, dts);
    // If it's CLI generation for JS asset and there's nothing found,
    // give a default output dist/index.js.
    // We don't do it for types generation or non-CLI bundle generation.
    if (!dts && isFromCli && outputExports.length === 0 && !pkg.bin) {
        const isEsmPkg = isESModulePackage(pkg.type);
        const defaultFormat = isEsmPkg ? 'esm' : 'cjs';
        outputExports.push({
            format: defaultFormat,
            file: path.join(cwd, 'dist/index.js'.replace('/', path__default.default.sep)),
            exportCondition: 'default'
        });
    }
    let bundleOptions = [];
    if (file) {
        const absoluteFile = path.resolve(cwd, file);
        const absoluteTypeFile = getExportFileTypePath(absoluteFile);
        if (dts) {
            bundleOptions = [
                {
                    file: absoluteTypeFile,
                    format: 'esm',
                    exportCondition: 'types'
                }
            ];
        } else {
            const fallbackExport = outputExports[0];
            bundleOptions = [
                {
                    file: absoluteFile,
                    format: bundleConfig.format || fallbackExport.format,
                    exportCondition: fallbackExport.exportCondition
                }
            ];
        }
    } else {
        // CLI output option is always prioritized
        if (dts) {
            // types could have duplicates, dedupe them
            // e.g. { types, import, .. } use the same `types` condition with all conditions
            const uniqTypes = new Set();
            outputExports.forEach((exportDist)=>{
                uniqTypes.add(path.resolve(cwd, exportDist.file));
            });
            bundleOptions = Array.from(uniqTypes).map((typeFile)=>{
                return {
                    file: typeFile,
                    format: 'esm',
                    exportCondition: 'types'
                };
            });
        } else {
            bundleOptions = outputExports.map((exportDist)=>{
                return {
                    file: path.resolve(cwd, exportDist.file),
                    format: exportDist.format,
                    exportCondition: exportDist.exportCondition
                };
            });
        }
    }
    const outputConfigs = bundleOptions.map(async (bundleOption)=>{
        const targetExportCondition = {
            ...exportCondition,
            export: {
                [bundleOption.exportCondition]: bundleOption.exportCondition === 'types' ? bundleOption.file : exportCondition.export[bundleOption.exportCondition]
            }
        };
        return await buildRollupConfigs(entry, {
            ...bundleConfig,
            file: bundleOption.file,
            format: bundleOption.format
        }, targetExportCondition, pluginContext, dts);
    });
    return Promise.all(outputConfigs);
}

async function createAssetRollupJobs(options, buildContext, bundleJobOptions) {
    const { isFromCli, generateTypes } = bundleJobOptions;
    const assetsConfigs = await buildEntryConfig(options, buildContext, {
        dts: false,
        isFromCli
    });
    const typesConfigs = generateTypes ? await buildEntryConfig(options, buildContext, {
        dts: true,
        isFromCli
    }) : [];
    const allConfigs = assetsConfigs.concat(typesConfigs);
    for (const config of allConfigs){
        if (options.clean && !isFromCli) {
            await removeOutputDir(config.output, buildContext.cwd);
        }
    }
    const rollupJobs = allConfigs.map((rollupConfig)=>bundleOrWatch(options, rollupConfig));
    return await Promise.all(rollupJobs);
}
async function bundleOrWatch(options, rollupConfig) {
    if (options.watch) {
        return runWatch(rollupConfig);
    }
    return runBundle(rollupConfig);
}
function runBundle({ input, output }) {
    return rollup.rollup(input).then((bundle)=>{
        return bundle.write(output);
    }, catchErrorHandler);
}
function runWatch({ input, output }) {
    const watchOptions = [
        {
            ...input,
            output: output,
            watch: {
                exclude: [
                    'node_modules/**'
                ]
            }
        }
    ];
    const watcher = rollup.watch(watchOptions);
    return watcher;
}
function catchErrorHandler(error) {
    if (!error) return;
    logger.error(error);
    // filter out the rollup plugin error information such as loc/frame/code...
    const err = new Error(error.message);
    err.stack = error.stack;
    throw err;
}

function assignDefault(options, name, defaultValue) {
    if (!(name in options) || options[name] == null) {
        options[name] = defaultValue;
    }
}
function hasMultiEntryExport(exportPaths) {
    const exportKeys = Object.keys(exportPaths).filter((key)=>key !== './package.json');
    return exportKeys.length > 0 && exportKeys.every((name)=>name.startsWith('.'));
}
async function bundle(cliEntryPath, { cwd: _cwd, ...options } = {}) {
    var _options__callbacks_onBuildStart, _options__callbacks, _options__callbacks_onBuildEnd, _options__callbacks1;
    const cwd = path.resolve(process.cwd(), _cwd || '');
    assignDefault(options, 'format', 'esm');
    assignDefault(options, 'minify', false);
    assignDefault(options, 'target', 'es2015');
    const pkg = await getPackageMeta(cwd);
    const parsedExportsInfo = parseExports(pkg);
    const isMultiEntries = hasMultiEntryExport(parsedExportsInfo);
    const hasBin = Boolean(pkg.bin);
    // Original input file path, client path might change later
    const inputFile = cliEntryPath;
    const isFromCli = Boolean(cliEntryPath);
    let tsConfig = resolveTsConfig(cwd, options.tsconfig);
    let hasTsConfig = Boolean(tsConfig == null ? void 0 : tsConfig.tsConfigPath);
    const defaultTsOptions = {
        tsConfigPath: tsConfig == null ? void 0 : tsConfig.tsConfigPath,
        tsCompilerOptions: (tsConfig == null ? void 0 : tsConfig.tsCompilerOptions) || {}
    };
    // Handle single entry file
    if (!isMultiEntries) {
        // Use specified string file path if possible, then fallback to the default behavior entry picking logic
        // e.g. "exports": "./dist/index.js" -> use "./index.<ext>" as entry
        cliEntryPath = cliEntryPath || await getSourcePathFromExportPath(cwd, '.', 'default') || '';
    }
    // Handle CLI input
    let mainExportPath;
    let typesEntryPath;
    if (isFromCli) {
        // with -o option
        if (options.file) {
            mainExportPath = options.file;
        }
        if (mainExportPath) {
            if (options.dts !== false) {
                typesEntryPath = getExportFileTypePath(mainExportPath);
            }
            parsedExportsInfo.set('./index', [
                [
                    mainExportPath,
                    'default'
                ],
                Boolean(typesEntryPath) && [
                    typesEntryPath,
                    'types'
                ]
            ].filter(Boolean));
        }
    }
    const hasSpecifiedEntryFile = cliEntryPath ? fs__default.default.existsSync(cliEntryPath) && (await fsp__default.default.stat(cliEntryPath)).isFile() : false;
    const hasNoEntry = !hasSpecifiedEntryFile && !isMultiEntries && !hasBin;
    if (hasNoEntry) {
        if (cliEntryPath) {
            const err = new Error(`Entry file "${cliEntryPath}" does not exist`);
            err.name = 'NOT_EXISTED';
            return Promise.reject(err);
        } else if (cwd) {
            const hasProjectDir = fs__default.default.existsSync(cwd) && (await fsp__default.default.stat(cwd)).isDirectory();
            if (!hasProjectDir) {
                const err = new Error(`Project directory "${cwd}" does not exist`);
                err.name = 'NOT_EXISTED';
                return Promise.reject(err);
            }
        }
    }
    const entries = await collectEntriesFromParsedExports(cwd, parsedExportsInfo, inputFile);
    const hasTypeScriptFiles = Object.values(entries).some((entry)=>isTypescriptFile(entry.source));
    if (hasTypeScriptFiles && !hasTsConfig) {
        const tsConfigPath = path.resolve(cwd, 'tsconfig.json');
        defaultTsOptions.tsConfigPath = tsConfigPath;
        await writeDefaultTsconfig(tsConfigPath);
        hasTsConfig = true;
    }
    const outputState = createOutputState({
        entries
    });
    const buildContext = {
        entries,
        pkg,
        cwd,
        tsOptions: defaultTsOptions,
        useTypeScript: hasTsConfig,
        pluginContext: {
            outputState,
            moduleDirectiveLayerMap: new Map()
        }
    };
    (_options__callbacks = options._callbacks) == null ? void 0 : (_options__callbacks_onBuildStart = _options__callbacks.onBuildStart) == null ? void 0 : _options__callbacks_onBuildStart.call(_options__callbacks, buildContext);
    const generateTypes = hasTsConfig && options.dts !== false;
    const rollupJobsOptions = {
        isFromCli,
        generateTypes
    };
    const assetJobs = await createAssetRollupJobs(options, buildContext, rollupJobsOptions);
    (_options__callbacks1 = options._callbacks) == null ? void 0 : (_options__callbacks_onBuildEnd = _options__callbacks1.onBuildEnd) == null ? void 0 : _options__callbacks_onBuildEnd.call(_options__callbacks1, assetJobs);
}

exports.bundle = bundle;
